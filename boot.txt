const { Client, LocalAuth, MessageMedia } = require('whatsapp-web.js');
const qrcode = require('qrcode-terminal');
const cron = require('node-cron');
const fs = require('fs');
const path = require('path');
const fetch = require('node-fetch');
const PdfPrinter = require('pdfmake');
const sqlite3 = require('sqlite3').verbose();

const client = new Client({ 
    authStrategy: new LocalAuth({ clientId: "whatsapp-bot" }),
    puppeteer: {
        headless: true,
        args: [
            '--no-sandbox',
            '--disable-setuid-sandbox',
            '--disable-dev-shm-usage',
            '--disable-accelerated-2d-canvas',
            '--no-first-run',
            '--no-zygote',
            '--disable-gpu'
        ]
    }
});

// Bot state and data
const userState = new Map();
const groupsMetadata = new Map();
const admins = new Set(['212715104027@c.us']); // Ø£Ø¶Ù Ù…Ø¹Ø±ÙÙƒ Ù‡Ù†Ø§ Ø¥Ø°Ø§ Ù„Ø²Ù… Ø§Ù„Ø£Ù…Ø±
const lectureStats = new Map();
const joinStats = new Map();
const leaveStats = new Map();
const messageStats = new Map();
const blacklist = new Set(); // ØªÙ… Ø¥Ø¶Ø§ÙØ© ØªØ¹Ø±ÙŠÙ Ø§Ù„Ù…ØªØºÙŠØ± Ø§Ù„Ù…ÙÙ‚ÙˆØ¯

// New data structures
const sections = new Map(); // Ø§Ù„Ø´Ø¹Ø¨
const classes = new Map(); // Ø§Ù„ÙØµÙˆÙ„
const groupsData = new Map(); // Ø§Ù„Ø£ÙÙˆØ§Ø¬
const professors = new Map(); // Ø§Ù„Ø£Ø³Ø§ØªØ°Ø©
const subjects = new Map(); // Ø§Ù„Ù…ÙˆØ§Ø¯

let groupId = null;
let requestCount = 0;
let isBotReady = false;
const PDF_ARCHIVE_GROUP = '120363403563982270@g.us';
const IMAGES_ARCHIVE_GROUP = '120363400468776166@g.us';
const OWNER_ID = '212621957775@c.us';
const PROTECTION_PASSWORD = process.env.BOT_PASSWORD || 'your_secure_password';
const GEMINI_API_KEY = process.env.GEMINI_API_KEY || 'YOUR_GEMINI_API_KEY';

let lecturesMetadata = [];
const lecturesDir = './lectures/';

if (!fs.existsSync(lecturesDir)) {
    fs.mkdirSync(lecturesDir);
}

// Ø¥Ø¹Ø¯Ø§Ø¯ Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
const db = new sqlite3.Database('./database.db', (err) => {
    if (err) {
        console.error('[âŒ] Error opening database:', err.message);
    } else {
        console.log('[âœ…] Connected to SQLite database');
        initializeDatabase();
    }
});

// Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ø¬Ø¯Ø§ÙˆÙ„ ÙÙŠ Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
function initializeDatabase() {
    // Ø¬Ø¯ÙˆÙ„ Ø§Ù„Ù…Ø­Ø§Ø¶Ø±Ø§Øª
    db.run(`CREATE TABLE IF NOT EXISTS lectures (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        type TEXT NOT NULL,
        subject TEXT NOT NULL,
        subjectId TEXT NOT NULL,
        lectureNumber TEXT NOT NULL,
        professor TEXT NOT NULL,
        professorId TEXT NOT NULL,
        groupNumber TEXT NOT NULL,
        groupId TEXT NOT NULL,
        className TEXT NOT NULL,
        classId TEXT NOT NULL,
        sectionName TEXT NOT NULL,
        sectionId TEXT NOT NULL,
        date TEXT NOT NULL,
        addedBy TEXT NOT NULL,
        fileName TEXT NOT NULL
    )`);

    // Ø¬Ø¯ÙˆÙ„ Ø§Ù„Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª
    db.run(`CREATE TABLE IF NOT EXISTS stats (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        groupId TEXT NOT NULL,
        userId TEXT,
        type TEXT NOT NULL,
        timestamp INTEGER NOT NULL,
        data TEXT
    )`);

    // Ø¬Ø¯ÙˆÙ„ Ø§Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø³ÙˆØ¯Ø§Ø¡
    db.run(`CREATE TABLE IF NOT EXISTS blacklist (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        userId TEXT NOT NULL UNIQUE,
        timestamp INTEGER NOT NULL
    )`);

    // Ø¬Ø¯ÙˆÙ„ Ø§Ù„Ø´Ø¹Ø¨
    db.run(`CREATE TABLE IF NOT EXISTS sections (
        id TEXT PRIMARY KEY,
        name TEXT NOT NULL
    )`);

    // Ø¬Ø¯ÙˆÙ„ Ø§Ù„ÙØµÙˆÙ„
    db.run(`CREATE TABLE IF NOT EXISTS classes (
        id TEXT PRIMARY KEY,
        name TEXT NOT NULL
    )`);

    // Ø¬Ø¯ÙˆÙ„ Ø§Ù„Ø£ÙÙˆØ§Ø¬
    db.run(`CREATE TABLE IF NOT EXISTS groups (
        id TEXT PRIMARY KEY,
        name TEXT NOT NULL
    )`);

    // Ø¬Ø¯ÙˆÙ„ Ø§Ù„Ø£Ø³Ø§ØªØ°Ø©
    db.run(`CREATE TABLE IF NOT EXISTS professors (
        id TEXT PRIMARY KEY,
        name TEXT NOT NULL
    )`);

    // Ø¬Ø¯ÙˆÙ„ Ø§Ù„Ù…ÙˆØ§Ø¯
    db.run(`CREATE TABLE IF NOT EXISTS subjects (
        id TEXT PRIMARY KEY,
        name TEXT NOT NULL
    )`);

    console.log('[âœ…] Database tables initialized');
}

// ØªØ¹Ø¯ÙŠÙ„ Ø¯ÙˆØ§Ù„ Ø§Ù„ØªØ­Ù…ÙŠÙ„ Ù„Ù„Ø¹Ù…Ù„ Ù…Ø¹ SQLite
function loadLectures() {
    return new Promise((resolve, reject) => {
        db.all("SELECT * FROM lectures", [], (err, rows) => {
            if (err) {
                console.error('[âŒ] Error loading lectures:', err);
                lecturesMetadata = [];
                reject(err);
            } else {
                lecturesMetadata = rows;
                console.log(`[ğŸ“‚] Loaded ${lecturesMetadata.length} lectures`);
                resolve();
            }
        });
    });
}

function loadStats() {
    return new Promise((resolve, reject) => {
        // Ù…Ø³Ø­ Ø§Ù„Ø®Ø±Ø§Ø¦Ø· Ø§Ù„Ø­Ø§Ù„ÙŠØ©
        joinStats.clear();
        leaveStats.clear();
        messageStats.clear();
        lectureStats.clear();
        
        db.all("SELECT * FROM stats", [], (err, rows) => {
            if (err) {
                console.error('[âŒ] Error loading stats:', err);
                reject(err);
            } else {
                rows.forEach(row => {
                    const data = row.data ? JSON.parse(row.data) : {};
                    
                    if (row.type === 'join') {
                        if (!joinStats.has(row.groupId)) {
                            joinStats.set(row.groupId, []);
                        }
                        joinStats.get(row.groupId).push({
                            userId: row.userId,
                            timestamp: row.timestamp
                        });
                    } else if (row.type === 'leave') {
                        if (!leaveStats.has(row.groupId)) {
                            leaveStats.set(row.groupId, []);
                        }
                        leaveStats.get(row.groupId).push({
                            userId: row.userId,
                            timestamp: row.timestamp,
                            reason: data.reason || 'left'
                        });
                    } else if (row.type === 'message') {
                        if (!messageStats.has(row.groupId)) {
                            messageStats.set(row.groupId, []);
                        }
                        messageStats.get(row.groupId).push({
                            userId: row.userId,
                            timestamp: row.timestamp,
                            count: data.count || 1
                        });
                    } else if (row.type === 'lecture') {
                        if (!lectureStats.has(row.userId)) {
                            lectureStats.set(row.userId, []);
                        }
                        lectureStats.get(row.userId).push({
                            name: data.name,
                            timestamp: row.timestamp
                        });
                    }
                });
                
                console.log(`[ğŸ“Š] Loaded stats`);
                resolve();
            }
        });
    });
}

function loadBlacklist() {
    return new Promise((resolve, reject) => {
        blacklist.clear(); // Ø§Ù„Ø¢Ù† Ø³ÙŠØªÙ… Ø§Ù„ØªØ¹Ø±Ù Ø¹Ù„Ù‰ Ø§Ù„Ù…ØªØºÙŠØ± blacklist
        
        db.all("SELECT userId FROM blacklist", [], (err, rows) => {
            if (err) {
                console.error('[âŒ] Error loading blacklist:', err);
                reject(err);
            } else {
                rows.forEach(row => {
                    blacklist.add(row.userId);
                });
                console.log(`[ğŸ“›] Loaded ${blacklist.size} blacklisted numbers`);
                resolve();
            }
        });
    });
}

function loadSections() {
    return new Promise((resolve, reject) => {
        sections.clear();
        
        db.all("SELECT id, name FROM sections", [], (err, rows) => {
            if (err) {
                console.error('[âŒ] Error loading sections:', err);
                reject(err);
            } else {
                rows.forEach(row => {
                    sections.set(row.id, row.name);
                });
                console.log(`[ğŸ“‚] Loaded ${sections.size} sections`);
                resolve();
            }
        });
    });
}

function loadClasses() {
    return new Promise((resolve, reject) => {
        classes.clear();
        
        db.all("SELECT id, name FROM classes", [], (err, rows) => {
            if (err) {
                console.error('[âŒ] Error loading classes:', err);
                reject(err);
            } else {
                rows.forEach(row => {
                    classes.set(row.id, row.name);
                });
                console.log(`[ğŸ“‚] Loaded ${classes.size} classes`);
                resolve();
            }
        });
    });
}

function loadGroups() {
    return new Promise((resolve, reject) => {
        groupsData.clear();
        
        db.all("SELECT id, name FROM groups", [], (err, rows) => {
            if (err) {
                console.error('[âŒ] Error loading groups:', err);
                reject(err);
            } else {
                rows.forEach(row => {
                    groupsData.set(row.id, row.name);
                });
                console.log(`[ğŸ“‚] Loaded ${groupsData.size} groups`);
                resolve();
            }
        });
    });
}

function loadProfessors() {
    return new Promise((resolve, reject) => {
        professors.clear();
        
        db.all("SELECT id, name FROM professors", [], (err, rows) => {
            if (err) {
                console.error('[âŒ] Error loading professors:', err);
                reject(err);
            } else {
                rows.forEach(row => {
                    professors.set(row.id, row.name);
                });
                console.log(`[ğŸ“‚] Loaded ${professors.size} professors`);
                resolve();
            }
        });
    });
}

function loadSubjects() {
    return new Promise((resolve, reject) => {
        subjects.clear();
        
        db.all("SELECT id, name FROM subjects", [], (err, rows) => {
            if (err) {
                console.error('[âŒ] Error loading subjects:', err);
                reject(err);
            } else {
                rows.forEach(row => {
                    subjects.set(row.id, row.name);
                });
                console.log(`[ğŸ“‚] Loaded ${subjects.size} subjects`);
                resolve();
            }
        });
    });
}

// ØªØ¹Ø¯ÙŠÙ„ Ø¯ÙˆØ§Ù„ Ø§Ù„Ø­ÙØ¸ Ù„Ù„Ø¹Ù…Ù„ Ù…Ø¹ SQLite
function saveLectures() {
    return new Promise((resolve, reject) => {
        // Ù…Ø³Ø­ Ø§Ù„Ø¬Ø¯ÙˆÙ„ Ø£ÙˆÙ„Ø§Ù‹
        db.run("DELETE FROM lectures", (err) => {
            if (err) {
                console.error('[âŒ] Error clearing lectures table:', err);
                reject(err);
                return;
            }
            
            // Ø¥Ø¯Ø®Ø§Ù„ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø¬Ø¯ÙŠØ¯Ø©
            const stmt = db.prepare("INSERT INTO lectures (type, subject, subjectId, lectureNumber, professor, professorId, groupNumber, groupId, className, classId, sectionName, sectionId, date, addedBy, fileName) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)");
            
            for (const lecture of lecturesMetadata) {
                stmt.run(
                    lecture.type,
                    lecture.subject,
                    lecture.subjectId,
                    lecture.lectureNumber,
                    lecture.professor,
                    lecture.professorId,
                    lecture.groupNumber,
                    lecture.groupId,
                    lecture.className,
                    lecture.classId,
                    lecture.sectionName,
                    lecture.sectionId,
                    lecture.date,
                    lecture.addedBy,
                    lecture.fileName
                );
            }
            
            stmt.finalize((err) => {
                if (err) {
                    console.error('[âŒ] Error saving lectures:', err);
                    reject(err);
                } else {
                    console.log('[ğŸ’¾] Saved lectures');
                    resolve();
                }
            });
        });
    });
}

function saveStats() {
    return new Promise((resolve, reject) => {
        // Ù…Ø³Ø­ Ø§Ù„Ø¬Ø¯ÙˆÙ„ Ø£ÙˆÙ„Ø§Ù‹
        db.run("DELETE FROM stats", (err) => {
            if (err) {
                console.error('[âŒ] Error clearing stats table:', err);
                reject(err);
                return;
            }
            
            const stmt = db.prepare("INSERT INTO stats (groupId, userId, type, timestamp, data) VALUES (?, ?, ?, ?, ?)");
            
            // Ø­ÙØ¸ Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ø§Ù„Ø§Ù†Ø¶Ù…Ø§Ù…
            for (const [groupId, joins] of joinStats) {
                for (const join of joins) {
                    stmt.run(
                        groupId,
                        join.userId,
                        'join',
                        join.timestamp,
                        null
                    );
                }
            }
            
            // Ø­ÙØ¸ Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ø§Ù„Ù…ØºØ§Ø¯Ø±Ø©
            for (const [groupId, leaves] of leaveStats) {
                for (const leave of leaves) {
                    stmt.run(
                        groupId,
                        leave.userId,
                        'leave',
                        leave.timestamp,
                        JSON.stringify({ reason: leave.reason })
                    );
                }
            }
            
            // Ø­ÙØ¸ Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ø§Ù„Ø±Ø³Ø§Ø¦Ù„
            for (const [groupId, messages] of messageStats) {
                for (const message of messages) {
                    stmt.run(
                        groupId,
                        message.userId,
                        'message',
                        message.timestamp,
                        JSON.stringify({ count: message.count })
                    );
                }
            }
            
            // Ø­ÙØ¸ Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ø§Ù„Ù…Ø­Ø§Ø¶Ø±Ø§Øª
            for (const [userId, lectures] of lectureStats) {
                for (const lecture of lectures) {
                    stmt.run(
                        null, // groupId
                        userId,
                        'lecture',
                        lecture.timestamp,
                        JSON.stringify({ name: lecture.name })
                    );
                }
            }
            
            stmt.finalize((err) => {
                if (err) {
                    console.error('[âŒ] Error saving stats:', err);
                    reject(err);
                } else {
                    console.log('[ğŸ’¾] Saved stats');
                    resolve();
                }
            });
        });
    });
}

function saveBlacklist() {
    return new Promise((resolve, reject) => {
        // Ù…Ø³Ø­ Ø§Ù„Ø¬Ø¯ÙˆÙ„ Ø£ÙˆÙ„Ø§Ù‹
        db.run("DELETE FROM blacklist", (err) => {
            if (err) {
                console.error('[âŒ] Error clearing blacklist table:', err);
                reject(err);
                return;
            }
            
            const stmt = db.prepare("INSERT INTO blacklist (userId, timestamp) VALUES (?, ?)");
            
            for (const userId of blacklist) {
                stmt.run(userId, Date.now());
            }
            
            stmt.finalize((err) => {
                if (err) {
                    console.error('[âŒ] Error saving blacklist:', err);
                    reject(err);
                } else {
                    console.log('[ğŸ’¾] Saved blacklist');
                    resolve();
                }
            });
        });
    });
}

function saveSections() {
    return new Promise((resolve, reject) => {
        // Ù…Ø³Ø­ Ø§Ù„Ø¬Ø¯ÙˆÙ„ Ø£ÙˆÙ„Ø§Ù‹
        db.run("DELETE FROM sections", (err) => {
            if (err) {
                console.error('[âŒ] Error clearing sections table:', err);
                reject(err);
                return;
            }
            
            const stmt = db.prepare("INSERT INTO sections (id, name) VALUES (?, ?)");
            
            for (const [id, name] of sections) {
                stmt.run(id, name);
            }
            
            stmt.finalize((err) => {
                if (err) {
                    console.error('[âŒ] Error saving sections:', err);
                    reject(err);
                } else {
                    console.log('[ğŸ’¾] Saved sections');
                    resolve();
                }
            });
        });
    });
}

function saveClasses() {
    return new Promise((resolve, reject) => {
        // Ù…Ø³Ø­ Ø§Ù„Ø¬Ø¯ÙˆÙ„ Ø£ÙˆÙ„Ø§Ù‹
        db.run("DELETE FROM classes", (err) => {
            if (err) {
                console.error('[âŒ] Error clearing classes table:', err);
                reject(err);
                return;
            }
            
            const stmt = db.prepare("INSERT INTO classes (id, name) VALUES (?, ?)");
            
            for (const [id, name] of classes) {
                stmt.run(id, name);
            }
            
            stmt.finalize((err) => {
                if (err) {
                    console.error('[âŒ] Error saving classes:', err);
                    reject(err);
                } else {
                    console.log('[ğŸ’¾] Saved classes');
                    resolve();
                }
            });
        });
    });
}

function saveGroups() {
    return new Promise((resolve, reject) => {
        // Ù…Ø³Ø­ Ø§Ù„Ø¬Ø¯ÙˆÙ„ Ø£ÙˆÙ„Ø§Ù‹
        db.run("DELETE FROM groups", (err) => {
            if (err) {
                console.error('[âŒ] Error clearing groups table:', err);
                reject(err);
                return;
            }
            
            const stmt = db.prepare("INSERT INTO groups (id, name) VALUES (?, ?)");
            
            for (const [id, name] of groupsData) {
                stmt.run(id, name);
            }
            
            stmt.finalize((err) => {
                if (err) {
                    console.error('[âŒ] Error saving groups:', err);
                    reject(err);
                } else {
                    console.log('[ğŸ’¾] Saved groups');
                    resolve();
                }
            });
        });
    });
}

function saveProfessors() {
    return new Promise((resolve, reject) => {
        // Ù…Ø³Ø­ Ø§Ù„Ø¬Ø¯ÙˆÙ„ Ø£ÙˆÙ„Ø§Ù‹
        db.run("DELETE FROM professors", (err) => {
            if (err) {
                console.error('[âŒ] Error clearing professors table:', err);
                reject(err);
                return;
            }
            
            const stmt = db.prepare("INSERT INTO professors (id, name) VALUES (?, ?)");
            
            for (const [id, name] of professors) {
                stmt.run(id, name);
            }
            
            stmt.finalize((err) => {
                if (err) {
                    console.error('[âŒ] Error saving professors:', err);
                    reject(err);
                } else {
                    console.log('[ğŸ’¾] Saved professors');
                    resolve();
                }
            });
        });
    });
}

function saveSubjects() {
    return new Promise((resolve, reject) => {
        // Ù…Ø³Ø­ Ø§Ù„Ø¬Ø¯ÙˆÙ„ Ø£ÙˆÙ„Ø§Ù‹
        db.run("DELETE FROM subjects", (err) => {
            if (err) {
                console.error('[âŒ] Error clearing subjects table:', err);
                reject(err);
                return;
            }
            
            const stmt = db.prepare("INSERT INTO subjects (id, name) VALUES (?, ?)");
            
            for (const [id, name] of subjects) {
                stmt.run(id, name);
            }
            
            stmt.finalize((err) => {
                if (err) {
                    console.error('[âŒ] Error saving subjects:', err);
                    reject(err);
                } else {
                    console.log('[ğŸ’¾] Saved subjects');
                    resolve();
                }
            });
        });
    });
}

// ØªØ­Ù…ÙŠÙ„ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø¹Ù†Ø¯ Ø¨Ø¯Ø¡ Ø§Ù„ØªØ´ØºÙŠÙ„
async function loadAllData() {
    try {
        await loadLectures();
        await loadStats();
        await loadBlacklist();
        await loadSections();
        await loadClasses();
        await loadGroups();
        await loadProfessors();
        await loadSubjects();
        console.log('[âœ…] All data loaded successfully');
    } catch (error) {
        console.error('[âŒ] Error loading data:', error);
    }
}

// Ø§Ø³ØªØ¯Ø¹Ø§Ø¡ Ø¯Ø§Ù„Ø© ØªØ­Ù…ÙŠÙ„ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
loadAllData();

const signature = "\nğŸ‘¨â€ğŸ’» *dev by: IRIZI ğŸ˜Š*";

// Ø¯Ø§Ù„Ø© Ù„Ù„ØªÙˆØ§ØµÙ„ Ù…Ø¹ Gemini API
async function askGemini(prompt, context = '') {
    try {
        const fullPrompt = context ? `${context}\n\nØ§Ù„Ø³Ø¤Ø§Ù„: ${prompt}` : prompt;
        
        const response = await fetch(
            `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${GEMINI_API_KEY}`,
            {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    contents: [
                        {
                            parts: [
                                {
                                    text: fullPrompt
                                }
                            ]
                        }
                    ]
                })
            }
        );

        const data = await response.json();

        if (data && data.candidates && data.candidates.length > 0) {
            const text = data.candidates[0].content.parts[0].text;
            return text;
        } else {
            return "Ø¹Ø°Ø±Ø§Ù‹ØŒ Ù„Ù… Ø£ØªÙ…ÙƒÙ† Ù…Ù† Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø¥Ø¬Ø§Ø¨Ø© Ù…Ù† Ø§Ù„Ø°ÙƒØ§Ø¡ Ø§Ù„Ø§ØµØ·Ù†Ø§Ø¹ÙŠ.";
        }
    } catch (error) {
        console.error('[âŒ] Error calling Gemini API:', error);
        return "Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø§Ù„Ø§ØªØµØ§Ù„ Ø¨Ø§Ù„Ø°ÙƒØ§Ø¡ Ø§Ù„Ø§ØµØ·Ù†Ø§Ø¹ÙŠ.";
    }
}

// Ø¯Ø§Ù„Ø© Ù„ØªØ­Ù„ÙŠÙ„ Ù†ÙŠØ© Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… Gemini
async function analyzeUserIntent(message, senderName, isGroup, groupName = '') {
    try {
        const context = `
Ø£Ù†Øª Ù…Ø³Ø§Ø¹Ø¯ Ø°ÙƒØ§Ø¡ Ø§ØµØ·Ù†Ø§Ø¹ÙŠ Ù„Ø¨ÙˆØª WhatsApp. Ù…Ù‡Ù…ØªÙƒ Ù‡ÙŠ ØªØ­Ù„ÙŠÙ„ Ù†ÙŠØ© Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ù…Ù† Ø±Ø³Ø§Ù„ØªÙ‡ ÙˆØ§Ù„Ø±Ø¯ Ø¨Ø´ÙƒÙ„ Ù…Ù†Ø§Ø³Ø¨.

Ø§Ù„Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„Ù…ØªØ§Ø­Ø©:
- Ø§Ø³Ù… Ø§Ù„Ù…Ø±Ø³Ù„: ${senderName}
- Ø§Ù„Ø±Ø³Ø§Ù„Ø© Ù…Ù† Ù…Ø¬Ù…ÙˆØ¹Ø©: ${isGroup ? 'Ù†Ø¹Ù…' : 'Ù„Ø§'}
${isGroup ? `- Ø§Ø³Ù… Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø©: ${groupName}` : ''}
- Ø§Ù„Ø±Ø³Ø§Ù„Ø©: ${message}

Ø§Ù„Ø±Ø¯ ÙŠØ¬Ø¨ Ø£Ù† ÙŠÙƒÙˆÙ† Ø¨ØªÙ†Ø³ÙŠÙ‚ JSON ÙŠØ­ØªÙˆÙŠ Ø¹Ù„Ù‰:
{
  "intent": "Ø§Ù„Ù†ÙŠØ© (Ù…Ø«Ù„: Ø³Ø¤Ø§Ù„ØŒ Ø´ÙƒÙˆÙ‰ØŒ Ø·Ù„Ø¨ Ù…Ø³Ø§Ø¹Ø¯Ø©ØŒ Ø¥Ù„Ø®)",
  "response": "Ø§Ù„Ø±Ø¯ Ø§Ù„Ù…Ù†Ø§Ø³Ø¨ Ù„Ù„Ù…Ø³ØªØ®Ø¯Ù…",
  "action": "Ø¥Ø¬Ø±Ø§Ø¡ ÙŠØ¬Ø¨ Ø¹Ù„Ù‰ Ø§Ù„Ø¨ÙˆØª Ø§ØªØ®Ø§Ø°Ù‡ (Ù…Ø«Ù„: none, notify_admin, add_to_blacklist, Ø¥Ù„Ø®)",
  "confidence": "Ù…Ø³ØªÙˆÙ‰ Ø§Ù„Ø«Ù‚Ø© (Ù…Ù† 0 Ø¥Ù„Ù‰ 1)"
}
`;

        const aiResponse = await askGemini(`Ø­Ù„Ù„ Ù†ÙŠØ© Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ù…Ù† Ù‡Ø°Ù‡ Ø§Ù„Ø±Ø³Ø§Ù„Ø© ÙˆØ±Ø¯ Ø¨Ø´ÙƒÙ„ Ù…Ù†Ø§Ø³Ø¨.`, context);
        
        try {
            return JSON.parse(aiResponse);
        } catch (parseError) {
            console.error('[âŒ] Error parsing AI response:', parseError);
            return {
                intent: "unknown",
                response: "Ø¹Ø°Ø±Ø§Ù‹ØŒ Ù„Ù… Ø£ÙÙ‡Ù… Ø±Ø³Ø§Ù„ØªÙƒ. Ù‡Ù„ ÙŠÙ…ÙƒÙ†Ùƒ ØªÙˆØ¶ÙŠØ­ Ù…Ø§ ØªØ­ØªØ§Ø¬Ù‡ØŸ",
                action: "none",
                confidence: 0.2
            };
        }
    } catch (error) {
        console.error('[âŒ] Error analyzing user intent:', error);
        return {
            intent: "unknown",
            response: "Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ù…Ø¹Ø§Ù„Ø¬Ø© Ø±Ø³Ø§Ù„ØªÙƒ. ÙŠØ±Ø¬Ù‰ Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ù…Ø±Ø© Ø£Ø®Ø±Ù‰ Ù„Ø§Ø­Ù‚Ø§Ù‹.",
            action: "none",
            confidence: 0.1
        };
    }
}

// Ø¯Ø§Ù„Ø© Ù„Ø¥Ù†Ø´Ø§Ø¡ Ø±Ø³Ø§Ø¦Ù„ ØªØ±Ø­ÙŠØ¨ Ù…Ø®ØµØµØ© Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ø°ÙƒØ§Ø¡ Ø§Ù„Ø§ØµØ·Ù†Ø§Ø¹ÙŠ
async function generateWelcomeMessage(userName, groupName) {
    try {
        const context = `
Ø£Ù†Øª Ù…Ø³Ø§Ø¹Ø¯ Ø°ÙƒØ§Ø¡ Ø§ØµØ·Ù†Ø§Ø¹ÙŠ Ù„Ø¨ÙˆØª WhatsApp. Ù…Ù‡Ù…ØªÙƒ Ù‡ÙŠ Ø¥Ù†Ø´Ø§Ø¡ Ø±Ø³Ø§Ù„Ø© ØªØ±Ø­ÙŠØ¨ Ø¯Ø§ÙØ¦Ø© ÙˆÙˆØ¯ÙŠØ© Ù„Ø¹Ø¶Ùˆ Ø¬Ø¯ÙŠØ¯ ÙÙŠ Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø©.

Ø§Ù„Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„Ù…ØªØ§Ø­Ø©:
- Ø§Ø³Ù… Ø§Ù„Ø¹Ø¶Ùˆ Ø§Ù„Ø¬Ø¯ÙŠØ¯: ${userName}
- Ø§Ø³Ù… Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø©: ${groupName}

Ø§Ù„Ø±Ø¯ ÙŠØ¬Ø¨ Ø£Ù† ÙŠÙƒÙˆÙ† Ø±Ø³Ø§Ù„Ø© ØªØ±Ø­ÙŠØ¨ Ù‚ØµÙŠØ±Ø© ÙˆØ¯Ø§ÙØ¦Ø©ØŒ Ù„Ø§ ØªØ²ÙŠØ¯ Ø¹Ù† 3 Ø£Ø³Ø·Ø±.
`;

        const aiResponse = await askGemini(`Ø£Ù†Ø´Ø¦ Ø±Ø³Ø§Ù„Ø© ØªØ±Ø­ÙŠØ¨ Ù„Ù„Ø¹Ø¶Ùˆ Ø§Ù„Ø¬Ø¯ÙŠØ¯.`, context);
        return aiResponse;
    } catch (error) {
        console.error('[âŒ] Error generating welcome message:', error);
        return `Ù…Ø±Ø­Ø¨Ø§Ù‹ ${userName} ÙÙŠ Ù…Ø¬Ù…ÙˆØ¹Ø© ${groupName}! ğŸ‰`;
    }
}

// Ø¯Ø§Ù„Ø© Ù„Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ÙˆØ¬ÙˆØ¯ Ø§Ù„Ø®Ø·ÙˆØ·
function checkFonts() {
    const fontsDir = path.join(__dirname, 'fonts');
    const regularFont = path.join(fontsDir, 'Amiri-Regular.ttf');
    const boldFont = path.join(fontsDir, 'Amiri-Bold.ttf');
    
    if (!fs.existsSync(fontsDir)) {
        console.log('[âŒ] Fonts directory not found. Creating...');
        fs.mkdirSync(fontsDir);
        return false;
    }
    
    if (!fs.existsSync(regularFont)) {
        console.log('[âŒ] Amiri-Regular.ttf not found in fonts directory');
        return false;
    }
    
    if (!fs.existsSync(boldFont)) {
        console.log('[âŒ] Amiri-Bold.ttf not found in fonts directory');
        return false;
    }
    
    console.log('[âœ…] All fonts are available');
    return true;
}

// Ø¯Ø§Ù„Ø© Ù„Ø¥Ù†Ø´Ø§Ø¡ Ø¬Ø¯ÙˆÙ„ Ø§Ù„Ù…Ø­Ø§Ø¶Ø±Ø§Øª ÙƒÙ…Ù„Ù PDF Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… pdfmake
async function generateLecturesTablePDF(lecturesData) {
    return new Promise((resolve, reject) => {
        try {
            console.log('[ğŸ“Š] Starting PDF generation...');
            console.log(`[ğŸ“Š] Number of lectures: ${lecturesData.length}`);
            
            // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ÙˆØ¬ÙˆØ¯ Ø§Ù„Ø®Ø·ÙˆØ·
            if (!checkFonts()) {
                reject(new Error('Ø§Ù„Ø®Ø·ÙˆØ· Ø§Ù„Ù…Ø·Ù„ÙˆØ¨Ø© ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯Ø©. ÙŠØ±Ø¬Ù‰ Ø§Ù„ØªØ£ÙƒØ¯ Ù…Ù† ÙˆØ¬ÙˆØ¯ Ù…Ù„ÙØ§Øª Amiri-Regular.ttf Ùˆ Amiri-Bold.ttf ÙÙŠ Ù…Ø¬Ù„Ø¯ fonts'));
                return;
            }

            // ØªØ¹Ø±ÙŠÙ Ø§Ù„Ø®Ø·ÙˆØ·
            const fonts = {
                Amiri: {
                    normal: path.join(__dirname, 'fonts/Amiri-Regular.ttf'),
                    bold: path.join(__dirname, 'fonts/Amiri-Bold.ttf'),
                }
            };

            console.log('[ğŸ“Š] Creating PDF printer...');
            const printer = new PdfPrinter(fonts);

            // Ø¥Ø¹Ø¯Ø§Ø¯ Ø§Ù„Ø¬Ø¯ÙˆÙ„
            console.log('[ğŸ“Š] Preparing table data...');
            const body = [
                [
                    { text: 'Ø§Ù„ØªØ³Ù„Ø³Ù„', bold: true },
                    { text: 'Ø§Ù„Ù…Ø§Ø¯Ø©', bold: true },
                    { text: 'Ø±Ù‚Ù… Ø§Ù„Ù…Ø­Ø§Ø¶Ø±Ø©', bold: true },
                    { text: 'Ø§Ù„Ø£Ø³ØªØ§Ø°', bold: true },
                    { text: 'Ø§Ù„ÙÙˆØ¬', bold: true },
                    { text: 'Ø§Ù„ØªØ§Ø±ÙŠØ®', bold: true }
                ]
            ];

            lecturesData.forEach((lecture, index) => {
                const date = lecture.date
                    ? new Date(lecture.date).toLocaleDateString('ar-EG')
                    : 'ØºÙŠØ± Ù…Ø­Ø¯Ø¯';

                body.push([
                    (index + 1).toString(),
                    lecture.subject || '',
                    lecture.lectureNumber || '',
                    lecture.professor || '',
                    lecture.groupNumber || '',
                    date
                ]);
            });

            console.log('[ğŸ“Š] Creating document definition...');
            const docDefinition = {
                defaultStyle: {
                    font: 'Amiri',
                    alignment: 'right', // Ù…Ø­Ø§Ø°Ø§Ø© Ø¹Ø±Ø¨ÙŠØ©
                    fontSize: 12
                },
                content: [
                    { text: 'Ø¬Ø¯ÙˆÙ„ Ø§Ù„Ù…Ø­Ø§Ø¶Ø±Ø§Øª', style: 'header' },
                    { text: `ØªØ§Ø±ÙŠØ® Ø§Ù„Ø¥Ù†Ø´Ø§Ø¡: ${new Date().toLocaleDateString('ar-EG')}`, alignment: 'left' },
                    {
                        table: {
                            headerRows: 1,
                            widths: ['auto', '*', 'auto', '*', 'auto', 'auto'],
                            body
                        },
                        layout: 'lightHorizontalLines'
                    },
                    { text: `Ø¥Ø¬Ù…Ø§Ù„ÙŠ Ø§Ù„Ù…Ø­Ø§Ø¶Ø±Ø§Øª: ${lecturesData.length}`, margin: [0, 10, 0, 0] },
                    { text: 'ØªÙ… Ø¥Ù†Ø´Ø§Ø¡ Ù‡Ø°Ø§ Ø§Ù„Ø¬Ø¯ÙˆÙ„ Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ø°ÙƒØ§Ø¡ Ø§Ù„Ø§ØµØ·Ù†Ø§Ø¹ÙŠ', alignment: 'center', fontSize: 10, color: 'gray' }
                ],
                styles: {
                    header: {
                        fontSize: 18,
                        bold: true,
                        alignment: 'center',
                        margin: [0, 0, 0, 10]
                    }
                },
                pageOrientation: 'landscape',
                pageSize: 'A4'
            };

            console.log('[ğŸ“Š] Creating PDF document...');
            const pdfDoc = printer.createPdfKitDocument(docDefinition);

            const chunks = [];
            pdfDoc.on('data', chunk => {
                chunks.push(chunk);
                console.log(`[ğŸ“Š] Received chunk: ${chunk.length} bytes`);
            });
            
            pdfDoc.on('end', () => {
                console.log('[ğŸ“Š] PDF generation completed');
                const buffer = Buffer.concat(chunks);
                console.log(`[ğŸ“Š] Final PDF size: ${buffer.length} bytes`);
                resolve(buffer);
            });
            
            pdfDoc.on('error', (error) => {
                console.error('[âŒ] PDF generation error:', error);
                reject(error);
            });
            
            pdfDoc.end();

        } catch (error) {
            console.error('[âŒ] Error in generateLecturesTablePDF:', error);
            reject(error);
        }
    });
}

// Utility functions
async function notifyAllGroups(messageText) {
    if (!isBotReady) return;
    
    try {
        const chats = await client.getChats();
        const groups = chats.filter(chat => chat.isGroup);
        for (const group of groups) {
            if (await isBotAdmin(group.id._serialized)) {
                await client.sendMessage(group.id._serialized, messageText + signature);
                console.log(`[ğŸ“¢] Sent to group: ${group.id._serialized}`);
            }
        }
    } catch (error) {
        console.error('[âŒ] Error notifying groups:', error);
    }
}

async function notifyAdmins(groupId, text) {
    if (!isBotReady) return;
    
    try {
        const chat = await client.getChatById(groupId);
        const admins = chat.participants.filter(p => p.isAdmin || p.isSuperAdmin);
        for (const admin of admins) {
            await client.sendMessage(admin.id._serialized, `ğŸ“¢ *Admin Notification*\n${text}${signature}`);
        }
    } catch (error) {
        console.error('[âŒ] Error notifying admins:', error);
    }
}

// Ø¯Ø§Ù„Ø© Ù…Ø­Ø³Ù†Ø© Ù„Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ØµÙ„Ø§Ø­ÙŠØ§Øª Ø§Ù„Ù…Ø´Ø±Ù
async function isAdmin(userId, groupId) {
    if (!isBotReady) {
        console.log('[âš ï¸] Bot not ready, returning false for admin check');
        return false;
    }
    
    try {
        console.log(`[ğŸ”] Checking admin status for user ${userId} in group ${groupId}`);
        
        // Owner is always admin
        if (userId === OWNER_ID) {
            console.log('[âœ…] User is owner, has admin rights');
            return true;
        }
        
        // Check if user is in admins list
        if (admins.has(userId)) {
            console.log('[âœ…] User is in admins list');
            return true;
        }
        
        // For private chats, no admin check needed
        if (!groupId || !groupId.includes('@g.us')) {
            console.log('[â„¹ï¸] Private chat, no admin check needed');
            return true;
        }
        
        const chat = await client.getChatById(groupId);
        if (!chat.isGroup) {
            console.log('[âŒ] Chat is not a group');
            return false;
        }
        
        // Check if user is group admin
        const groupAdmins = chat.participants.filter(p => p.isAdmin || p.isSuperAdmin);
        const isAdmin = groupAdmins.some(admin => admin.id._serialized === userId);
        
        console.log(`[ğŸ”] Group admins: ${groupAdmins.map(a => a.id._serialized).join(', ')}`);
        console.log(`[ğŸ”] User is group admin: ${isAdmin}`);
        
        return isAdmin;
    } catch (error) {
        console.error('[âŒ] Error checking admin status:', error);
        return false;
    }
}

// Ø¯Ø§Ù„Ø© Ù…Ø­Ø³Ù†Ø© Ù„Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ØµÙ„Ø§Ø­ÙŠØ§Øª Ø§Ù„Ø¨ÙˆØª
async function isBotAdmin(groupId) {
    if (!isBotReady) {
        console.log('[âš ï¸] Bot not ready, returning false for bot admin check');
        return false;
    }
    
    try {
        console.log(`[ğŸ”] Checking if bot is admin in group ${groupId}`);
        
        const chat = await client.getChatById(groupId);
        const botId = client.info.wid._serialized;
        const admins = chat.participants.filter(p => p.isAdmin || p.isSuperAdmin);
        const isBotAdmin = admins.some(admin => admin.id._serialized === botId);
        
        console.log(`[ğŸ”] Bot ID: ${botId}`);
        console.log(`[ğŸ”] Group admins: ${admins.map(a => a.id._serialized).join(', ')}`);
        console.log(`[ğŸ”] Bot is admin: ${isBotAdmin}`);
        
        return isBotAdmin;
    } catch (error) {
        console.error('[âŒ] Error checking bot admin status:', error);
        return false;
    }
}

async function verifyGroup(groupId, groupName) {
    if (!isBotReady) return false;
    
    try {
        await client.getChatById(groupId);
        return true;
    } catch (error) {
        console.error(`[âŒ] Error: Group ${groupName} not found:`, error);
        return false;
    }
}

function formatPhoneNumber(number) {
    number = number.replace(/\D/g, '');
    if (!number.startsWith('+')) number = '+' + number;
    return number;
}

// Client events with enhanced debugging
client.on('qr', qr => {
    console.log('[ğŸ“¸] Scan QR code:');
    qrcode.generate(qr, { small: true });
});

client.on('authenticated', () => {
    console.log('[âœ…] Authenticated successfully!');
});

client.on('auth_failure', msg => {
    console.error('[âŒ] Authentication failure:', msg);
    isBotReady = false;
});

client.on('ready', async () => {
    console.log('[âœ…] Client ready!');
    isBotReady = true;
    
    try {
        const chats = await client.getChats();
        for (const chat of chats) {
            if (chat.isGroup) {
                groupsMetadata.set(chat.id._serialized, chat.name);
            }
        }
        console.log(`[â„¹ï¸] Loaded ${groupsMetadata.size} groups`);
        
        // Send test message to owner with delay
        setTimeout(async () => {
            try {
                if (isBotReady) {
                    await client.sendMessage(OWNER_ID, 'âœ… Ø§Ù„Ø¨ÙˆØª ÙŠØ¹Ù…Ù„ Ø§Ù„Ø¢Ù†!' + signature);
                    console.log('[ğŸ“¤] Test message sent to owner');
                }
            } catch (error) {
                console.error('[âŒ] Error sending test message:', error);
            }
        }, 5000); // Wait 5 seconds before sending
    } catch (error) {
        console.error('[âŒ] Error in ready event:', error);
    }
});

client.on('disconnected', reason => {
    console.log('[âŒ] Client disconnected:', reason);
    isBotReady = false;
});

client.on('group_join', async (notification) => {
    if (!isBotReady) return;
    
    const groupId = notification.chatId;
    const userId = notification.id.participant;
    console.log(`[ğŸ“¢] User ${userId} joined ${groupId}`);
    
    if (blacklist.has(userId)) {
        if (await isBotAdmin(groupId)) {
            await client.removeParticipant(groupId, userId);
            console.log(`[ğŸ“›] Removed blacklisted user ${userId}`);
        }
        return;
    }
    
    joinStats.set(groupId, joinStats.get(groupId) || []);
    joinStats.get(groupId).push({ userId, timestamp: Date.now() });
    await saveStats(); // Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ø¯Ø§Ù„Ø© Ø§Ù„Ù…Ø­Ø¯Ø«Ø©
    
    // Generate AI welcome message
    try {
        const contact = await client.getContactById(userId);
        const userName = contact.pushname || contact.name || "Ø¹Ø¶Ùˆ Ø¬Ø¯ÙŠØ¯";
        const groupName = groupsMetadata.get(groupId) || "Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø©";
        
        const welcomeMessage = await generateWelcomeMessage(userName, groupName);
        await client.sendMessage(groupId, welcomeMessage);
    } catch (error) {
        console.error('[âŒ] Error sending AI welcome message:', error);
    }
});

client.on('group_leave', async (notification) => {
    if (!isBotReady) return;
    
    const groupId = notification.chatId;
    const userId = notification.id.participant;
    console.log(`[ğŸ“¢] User ${userId} left ${groupId}`);
    blacklist.add(userId);
    await saveBlacklist(); // Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ø¯Ø§Ù„Ø© Ø§Ù„Ù…Ø­Ø¯Ø«Ø©
    leaveStats.set(groupId, leaveStats.get(groupId) || []);
    leaveStats.get(groupId).push({ userId, timestamp: Date.now(), reason: 'left' });
    await saveStats(); // Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ø¯Ø§Ù„Ø© Ø§Ù„Ù…Ø­Ø¯Ø«Ø©
});

client.on('group_admin_changed', async (notification) => {
    if (!isBotReady) return;
    
    const groupId = notification.chatId;
    const userId = notification.id.participant;
    if (notification.type === 'remove' && userId === OWNER_ID) {
        if (await isBotAdmin(groupId)) {
            await client.addParticipant(groupId, OWNER_ID);
            await client.sendMessage(OWNER_ID, `âš ï¸ You were removed from ${groupId}!\nâœ… Re-added you.${signature}`);
        }
    }
});

// Message handler with detailed debugging
client.on('message_create', async message => {
    try {
        if (!isBotReady) {
            console.log('[âš ï¸] Bot not ready, ignoring message');
            return;
        }
        
        console.log('=== NEW MESSAGE ===');
        console.log('From:', message.from);
        console.log('Body:', message.body);
        console.log('Author:', message.author);
        console.log('Is Group:', message.from.includes('@g.us'));
        
        if (!message || !message.from) {
            console.log('[âš ï¸] Invalid message, ignoring.');
            return;
        }

        // Ø§Ø³ØªØ®Ù„Ø§Øµ Ù…Ø¹Ø±Ù Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø¨Ø´ÙƒÙ„ ØµØ­ÙŠØ­
        let userId;
        if (message.from.includes('@g.us')) {
            // Ø±Ø³Ø§Ù„Ø© Ù…Ù† Ù…Ø¬Ù…ÙˆØ¹Ø©
            userId = message.author || message.from;
        } else {
            // Ø±Ø³Ø§Ù„Ø© Ø®Ø§ØµØ©
            userId = message.from;
        }

        console.log(`[ğŸ”] Extracted user ID: ${userId}`);
        console.log(`[ğŸ”] Message from: ${message.from}`);
        console.log(`[ğŸ”] Message author: ${message.author}`);
        
        const contact = await message.getContact();
        const senderName = contact.pushname || contact.name || "User";
        const content = message.body && typeof message.body === 'string' ? message.body.trim() : '';
        const isGroupMessage = message.from.includes('@g.us');
        const currentGroupId = isGroupMessage ? message.from : groupId;
        const replyTo = isGroupMessage ? currentGroupId : userId;
        const groupName = isGroupMessage ? (groupsMetadata.get(currentGroupId) || "Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø©") : "";

        console.log(`[ğŸ“©] Message from ${senderName} (${userId}): ${content || '[non-text]'}`);

        // Command to check admin status
        if (content === '!checkadmin' || content === '!ØªØ­Ù‚Ù‚') {
            await message.react('ğŸ”');
            
            const isAdminStatus = await isAdmin(userId, currentGroupId);
            const botAdminStatus = await isBotAdmin(currentGroupId);
            
            await client.sendMessage(replyTo, `
ğŸ” *ØªØ­Ù‚Ù‚ Ø§Ù„ØµÙ„Ø§Ø­ÙŠØ§Øª*

- Ù…Ø¹Ø±Ù Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…: ${userId}
- Ù…Ø¹Ø±Ù Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø©: ${currentGroupId}
- Ù‡Ù„ Ø£Ù†Øª Ù…Ø´Ø±Ù: ${isAdminStatus ? 'âœ… Ù†Ø¹Ù…' : 'âŒ Ù„Ø§'}
- Ù‡Ù„ Ø§Ù„Ø¨ÙˆØª Ù…Ø´Ø±Ù: ${botAdminStatus ? 'âœ… Ù†Ø¹Ù…' : 'âŒ Ù„Ø§'}
- Ø­Ø§Ù„Ø© Ø§Ù„Ø¨ÙˆØª: ${isBotReady ? 'âœ… Ø¬Ø§Ù‡Ø²' : 'âŒ Ù„ÙŠØ³ Ø¬Ø§Ù‡Ø²Ù‹Ø§'}${signature}
            `);
            return;
        }

        // AI command - ask AI
        if (content.startsWith('!ask ')) {
            const question = content.substring(5).trim();
            if (!question) {
                await client.sendMessage(replyTo, `âš ï¸ ÙŠØ±Ø¬Ù‰ ÙƒØªØ§Ø¨Ø© Ø³Ø¤Ø§Ù„ Ø¨Ø¹Ø¯ Ø§Ù„Ø£Ù…Ø± !ask${signature}`);
                return;
            }
            
            await message.react('ğŸ¤–');
            await client.sendMessage(replyTo, `ğŸ¤– *Ø¬Ø§Ø±ÙŠ Ù…Ø¹Ø§Ù„Ø¬Ø© Ø³Ø¤Ø§Ù„Ùƒ...*`);
            
            try {
                const aiResponse = await askGemini(question);
                await client.sendMessage(replyTo, `${aiResponse}${signature}`);
            } catch (error) {
                console.error('[âŒ] Error in AI command:', error);
                await client.sendMessage(replyTo, `âš ï¸ Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ù…Ø¹Ø§Ù„Ø¬Ø© Ø³Ø¤Ø§Ù„Ùƒ. ÙŠØ±Ø¬Ù‰ Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ù…Ø±Ø© Ø£Ø®Ø±Ù‰ Ù„Ø§Ø­Ù‚Ø§Ù‹.${signature}`);
            }
            return;
        }

        // AI command - analyze intent
        if (content === '!analyze' || content === '!ØªØ­Ù„ÙŠÙ„') {
            if (!isGroupMessage) {
                await client.sendMessage(replyTo, `âš ï¸ Ù‡Ø°Ø§ Ø§Ù„Ø£Ù…Ø± ÙŠØ¹Ù…Ù„ ÙÙŠ Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø§Øª ÙÙ‚Ø·!${signature}`);
                return;
            }
            
            await message.react('ğŸ”');
            await client.sendMessage(replyTo, `ğŸ” *Ø¬Ø§Ø±ÙŠ ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ø±Ø³Ø§Ø¦Ù„ Ø§Ù„Ø£Ø®ÙŠØ±Ø©...*`);
            
            try {
                // Get recent messages
                const chat = await client.getChatById(currentGroupId);
                const messages = await chat.fetchMessages({ limit: 10 });
                
                // Analyze each message
                for (const msg of messages.reverse()) {
                    if (msg.body && !msg.body.startsWith('!')) {
                        const msgContact = await msg.getContact();
                        const msgSenderName = msgContact.pushname || msgContact.name || "User";
                        
                        const analysis = await analyzeUserIntent(msg.body, msgSenderName, true, groupName);
                        
                        if (analysis.confidence > 0.7 && analysis.action !== 'none') {
                            // Take action based on analysis
                            if (analysis.action === 'notify_admin') {
                                await notifyAdmins(currentGroupId, `ğŸ” *ØªØ­Ù„ÙŠÙ„ Ø°ÙƒØ§Ø¡ Ø§ØµØ·Ù†Ø§Ø¹ÙŠ*\n\n${msgSenderName}: ${msg.body}\n\nØ§Ù„Ù†ÙŠØ©: ${analysis.intent}\nØ§Ù„Ø±Ø¯ Ø§Ù„Ù…Ù‚ØªØ±Ø­: ${analysis.response}`);
                            }
                        }
                    }
                }
                
                await client.sendMessage(replyTo, `âœ… *Ø§ÙƒØªÙ…Ù„ ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ø±Ø³Ø§Ø¦Ù„!*${signature}`);
            } catch (error) {
                console.error('[âŒ] Error in analyze command:', error);
                await client.sendMessage(replyTo, `âš ï¸ Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ø±Ø³Ø§Ø¦Ù„. ÙŠØ±Ø¬Ù‰ Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ù…Ø±Ø© Ø£Ø®Ø±Ù‰ Ù„Ø§Ø­Ù‚Ø§Ù‹.${signature}`);
            }
            return;
        }

        // AI command - generate content
        if (content.startsWith('!generate ')) {
            const prompt = content.substring(9).trim();
            if (!prompt) {
                await client.sendMessage(replyTo, `âš ï¸ ÙŠØ±Ø¬Ù‰ ÙƒØªØ§Ø¨Ø© ÙˆØµÙ Ù„Ù„Ù…Ø­ØªÙˆÙ‰ Ø¨Ø¹Ø¯ Ø§Ù„Ø£Ù…Ø± !generate${signature}`);
                return;
            }
            
            await message.react('âœï¸');
            await client.sendMessage(replyTo, `âœï¸ *Ø¬Ø§Ø±ÙŠ Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ù…Ø­ØªÙˆÙ‰...*`);
            
            try {
                const aiResponse = await askGemini(`Ø£Ù†Ø´Ø¦ Ù…Ø­ØªÙˆÙ‰ Ø¨Ù†Ø§Ø¡Ù‹ Ø¹Ù„Ù‰ Ø§Ù„ÙˆØµÙ Ø§Ù„ØªØ§Ù„ÙŠ: ${prompt}`);
                await client.sendMessage(replyTo, `${aiResponse}${signature}`);
            } catch (error) {
                console.error('[âŒ] Error in generate command:', error);
                await client.sendMessage(replyTo, `âš ï¸ Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ù…Ø­ØªÙˆÙ‰. ÙŠØ±Ø¬Ù‰ Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ù…Ø±Ø© Ø£Ø®Ø±Ù‰ Ù„Ø§Ø­Ù‚Ø§Ù‹.${signature}`);
            }
            return;
        }

        // Command to generate lectures table PDF
        if (content === '!Ø¬Ø¯ÙˆÙ„_Ø§Ù„Ù…Ø­Ø§Ø¶Ø±Ø§Øª' || content === '!lectures_table') {
            await message.react('ğŸ“Š');
            await client.sendMessage(replyTo, `ğŸ“Š *Ø¬Ø§Ø±ÙŠ Ø¥Ù†Ø´Ø§Ø¡ Ø¬Ø¯ÙˆÙ„ Ø§Ù„Ù…Ø­Ø§Ø¶Ø±Ø§Øª Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… pdfmake...*`);
            
            try {
                console.log(`[ğŸ“Š] User requested lectures table. Current lectures count: ${lecturesMetadata.length}`);
                
                if (lecturesMetadata.length === 0) {
                    await client.sendMessage(replyTo, `âš ï¸ Ù„Ø§ ØªÙˆØ¬Ø¯ Ù…Ø­Ø§Ø¶Ø±Ø§Øª Ù…Ø¶Ø§ÙØ© Ø¨Ø¹Ø¯!${signature}`);
                    await message.react('âŒ');
                    return;
                }
                
                const pdfBuffer = await generateLecturesTablePDF(lecturesMetadata);
                
                // Create Media object from buffer
                const media = new MessageMedia(
                    'application/pdf',
                    pdfBuffer.toString('base64'),
                    `Ø¬Ø¯ÙˆÙ„_Ø§Ù„Ù…Ø­Ø§Ø¶Ø±Ø§Øª_${new Date().toISOString().split('T')[0]}.pdf`
                );
                
                await client.sendMessage(replyTo, media, {
                    caption: `ğŸ“Š *Ø¬Ø¯ÙˆÙ„ Ø§Ù„Ù…Ø­Ø§Ø¶Ø±Ø§Øª*\n\nØªÙ… Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ø¬Ø¯ÙˆÙ„ Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… pdfmake!\nğŸ“… Ø§Ù„ØªØ§Ø±ÙŠØ®: ${new Date().toLocaleDateString('ar-EG')}\nğŸ“ Ø¹Ø¯Ø¯ Ø§Ù„Ù…Ø­Ø§Ø¶Ø±Ø§Øª: ${lecturesMetadata.length}\nğŸ¤– ØªÙ… Ø¥Ù†Ø´Ø§Ø¤Ù‡ Ø¨ÙˆØ§Ø³Ø·Ø© Gemini AI${signature}`
                });
                
                await message.react('âœ…');
                console.log('[âœ…] Lectures table sent successfully');
            } catch (error) {
                console.error('[âŒ] Error generating lectures table:', error);
                await client.sendMessage(replyTo, `âš ï¸ Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø¥Ù†Ø´Ø§Ø¡ Ø¬Ø¯ÙˆÙ„ Ø§Ù„Ù…Ø­Ø§Ø¶Ø±Ø§Øª: ${error.message}${signature}`);
                await message.react('âŒ');
            }
            
            return;
        }

        // Pin message command
        if (isGroupMessage && content === '!ØªØ«Ø¨ÙŠØª' && message.hasQuotedMsg) {
            if (await isAdmin(userId, currentGroupId)) {
                if (await isBotAdmin(currentGroupId)) {
                    const quotedMsg = await message.getQuotedMessage();
                    await quotedMsg.pin();
                    await client.sendMessage(OWNER_ID, `âœ… Pinned message in ${currentGroupId}${signature}`);
                } else {
                    await client.sendMessage(OWNER_ID, `âš ï¸ I'm not an admin in ${currentGroupId}!${signature}`);
                }
            }
            return;
        }

        // Add PDF command - Ù…ØªØ§Ø­ Ù„Ø¬Ù…ÙŠØ¹ Ø£Ø¹Ø¶Ø§Ø¡ Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø©
        if (content === '!Ø§Ø¶Ø§ÙØ©_pdf' || content === '!add pdf') {
            if (isGroupMessage) {
                // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ÙˆØ¬ÙˆØ¯ Ø¨ÙŠØ§Ù†Ø§Øª
                if (sections.size === 0 || classes.size === 0 || groupsData.size === 0 || 
                    professors.size === 0 || subjects.size === 0) {
                    await message.react('âš ï¸');
                    await client.sendMessage(replyTo, `âš ï¸ Ù„Ù… ÙŠØªÙ… Ø¥Ø¹Ø¯Ø§Ø¯ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø´Ø¹Ø¨ Ø£Ùˆ Ø§Ù„ÙØµÙˆÙ„ Ø£Ùˆ Ø§Ù„Ø£ÙÙˆØ§Ø¬ Ø£Ùˆ Ø§Ù„Ø£Ø³Ø§ØªØ°Ø© Ø£Ùˆ Ø§Ù„Ù…ÙˆØ§Ø¯ Ø¨Ø¹Ø¯!${signature}`);
                    return;
                }
                
                await message.react('ğŸ“„');
                await client.sendMessage(replyTo, `
ğŸ“„ *Ø¥Ø¶Ø§ÙØ© Ù…Ù„Ù PDF*
Ù…Ø±Ø­Ø¨Ø§Ù‹ ${senderName}! ğŸ™‹â€â™‚ï¸
ÙŠØ±Ø¬Ù‰ Ø§Ø®ØªÙŠØ§Ø± Ù†ÙˆØ¹ Ø§Ù„Ù…Ù„Ù:
1. Ù…Ø­Ø§Ø¶Ø±Ø©
2. Ù…Ù„Ø®Øµ

ğŸ’¡ Ø£Ø±Ø³Ù„ Ø±Ù‚Ù… Ø§Ù„Ø®ÙŠØ§Ø± Ø£Ùˆ *Ø¥Ù„ØºØ§Ø¡* Ù„Ù„Ø®Ø±ÙˆØ¬${signature}
                `);
                userState.set(userId, { 
                    step: 'select_pdf_type', 
                    timestamp: Date.now() 
                });
            } else {
                await message.react('âš ï¸');
                await client.sendMessage(replyTo, `âš ï¸ Ù‡Ø°Ø§ Ø§Ù„Ø£Ù…Ø± ÙŠØ¹Ù…Ù„ ÙÙŠ Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø§Øª ÙÙ‚Ø·!${signature}`);
            }
            return;
        }

        // Download PDF command - Ù…ØªØ§Ø­ Ù„Ø¬Ù…ÙŠØ¹ Ø£Ø¹Ø¶Ø§Ø¡ Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø©
        if (content === '!ØªØ­Ù…ÙŠÙ„' || content === '!download') {
            if (isGroupMessage) {
                // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ÙˆØ¬ÙˆØ¯ Ø¨ÙŠØ§Ù†Ø§Øª
                if (sections.size === 0 || classes.size === 0 || groupsData.size === 0 || 
                    professors.size === 0 || subjects.size === 0) {
                    await message.react('âš ï¸');
                    await client.sendMessage(replyTo, `âš ï¸ Ù„Ù… ÙŠØªÙ… Ø¥Ø¹Ø¯Ø§Ø¯ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø´Ø¹Ø¨ Ø£Ùˆ Ø§Ù„ÙØµÙˆÙ„ Ø£Ùˆ Ø§Ù„Ø£ÙÙˆØ§Ø¬ Ø£Ùˆ Ø§Ù„Ø£Ø³Ø§ØªØ°Ø© Ø£Ùˆ Ø§Ù„Ù…ÙˆØ§Ø¯ Ø¨Ø¹Ø¯!${signature}`);
                    return;
                }
                
                await message.react('ğŸ“¥');
                await client.sendMessage(replyTo, `
ğŸ“¥ *ØªØ­Ù…ÙŠÙ„ Ù…Ù„Ù PDF*
Ù…Ø±Ø­Ø¨Ø§Ù‹ ${senderName}! ğŸ™‹â€â™‚ï¸
ÙŠØ±Ø¬Ù‰ Ø§Ø®ØªÙŠØ§Ø± Ù†ÙˆØ¹ Ø§Ù„Ù…Ù„Ù:
1. Ù…Ø­Ø§Ø¶Ø±Ø©
2. Ù…Ù„Ø®Øµ

ğŸ’¡ Ø£Ø±Ø³Ù„ Ø±Ù‚Ù… Ø§Ù„Ø®ÙŠØ§Ø± Ø£Ùˆ *Ø¥Ù„ØºØ§Ø¡* Ù„Ù„Ø®Ø±ÙˆØ¬${signature}
                `);
                userState.set(userId, { 
                    step: 'select_download_type', 
                    timestamp: Date.now() 
                });
            } else {
                await message.react('âš ï¸');
                await client.sendMessage(replyTo, `âš ï¸ Ù‡Ø°Ø§ Ø§Ù„Ø£Ù…Ø± ÙŠØ¹Ù…Ù„ ÙÙŠ Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø§Øª ÙÙ‚Ø·!${signature}`);
            }
            return;
        }

        // Course management command
        if (content === '!Ø§Ù„Ù…Ù‚Ø±Ø±Ø§Øª' || content === '!courses') {
            if (!isGroupMessage) {
                await client.sendMessage(replyTo, `âš ï¸ Ù‡Ø°Ø§ Ø§Ù„Ø£Ù…Ø± ÙŠØ¹Ù…Ù„ ÙÙŠ Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø§Øª ÙÙ‚Ø·!${signature}`);
                return;
            }
            
            // Check if user is admin
            if (!(await isAdmin(userId, currentGroupId))) {
                await client.sendMessage(replyTo, `âš ï¸ Ù‡Ø°Ø§ Ø§Ù„Ø£Ù…Ø± Ù…ØªÙˆÙØ± Ù„Ù„Ù…Ø´Ø±ÙÙŠÙ† ÙÙ‚Ø·!${signature}`);
                return;
            }
            
            await message.react('ğŸ“š');
            await client.sendMessage(replyTo, `
ğŸ“š *Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ù…Ù‚Ø±Ø±Ø§Øª Ø§Ù„Ø¯Ø±Ø§Ø³ÙŠØ©*

Ù…Ø±Ø­Ø¨Ø§Ù‹ ${senderName}! ğŸ™‹â€â™‚ï¸
ÙŠØ±Ø¬Ù‰ Ø§Ø®ØªÙŠØ§Ø± Ø§Ù„Ù†ÙˆØ¹ Ø§Ù„Ø°ÙŠ ØªØ±ÙŠØ¯ Ø¥Ø¯Ø§Ø±ØªÙ‡:

1. Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ø´Ø¹Ø¨
2. Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„ÙØµÙˆÙ„
3. Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ø£ÙÙˆØ§Ø¬
4. Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ø£Ø³Ø§ØªØ°Ø©
5. Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ù…ÙˆØ§Ø¯

ğŸ’¡ Ø£Ø±Ø³Ù„ Ø±Ù‚Ù… Ø§Ù„Ø®ÙŠØ§Ø± Ø£Ùˆ *Ø¥Ù„ØºØ§Ø¡* Ù„Ù„Ø®Ø±ÙˆØ¬${signature}
            `);
            
            userState.set(userId, { 
                step: 'select_management_type', 
                timestamp: Date.now() 
            });
            return;
        }

        // Handle user responses for course management
        if (userState.has(userId)) {
            const state = userState.get(userId);
            const currentTime = Date.now();
            
            // Check if state has expired (5 minutes)
            if (currentTime - state.timestamp > 300000) {
                userState.delete(userId);
                await client.sendMessage(replyTo, `â±ï¸ Ø§Ù†ØªÙ‡Øª Ø§Ù„Ø¬Ù„Ø³Ø©. ÙŠØ±Ø¬Ù‰ Ø¥Ø¹Ø§Ø¯Ø© Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ø£Ù…Ø± !Ø§Ù„Ù…Ù‚Ø±Ø±Ø§Øª${signature}`);
                return;
            }
            
            // Check for cancellation
            if (content === 'Ø¥Ù„ØºØ§Ø¡' || content === 'cancel') {
                userState.delete(userId);
                await client.sendMessage(replyTo, `âœ… ØªÙ… Ø¥Ù„ØºØ§Ø¡ Ø§Ù„Ø¹Ù…Ù„ÙŠØ©${signature}`);
                return;
            }
            
            // Handle different steps
            switch (state.step) {
                case 'select_management_type':
                    if (content === '1') { // Sections
                        await handleSectionsManagement(message, replyTo, senderName, signature, userId, currentGroupId);
                    } else if (content === '2') { // Classes
                        await handleClassesManagement(message, replyTo, senderName, signature, userId, currentGroupId);
                    } else if (content === '3') { // Groups
                        await handleGroupsManagement(message, replyTo, senderName, signature, userId, currentGroupId);
                    } else if (content === '4') { // Professors
                        await handleProfessorsManagement(message, replyTo, senderName, signature, userId, currentGroupId);
                    } else if (content === '5') { // Subjects
                        await handleSubjectsManagement(message, replyTo, senderName, signature, userId, currentGroupId);
                    } else {
                        await client.sendMessage(replyTo, `âš ï¸ Ø®ÙŠØ§Ø± ØºÙŠØ± ØµØ§Ù„Ø­. ÙŠØ±Ø¬Ù‰ Ø¥Ø±Ø³Ø§Ù„ Ø±Ù‚Ù… Ù…Ù† 1 Ø¥Ù„Ù‰ 5${signature}`);
                    }
                    break;
                    
                case 'sections_action':
                    await handleSectionsAction(message, replyTo, senderName, signature, userId, currentGroupId, content);
                    break;
                    
                case 'add_section':
                    await handleAddSection(message, replyTo, senderName, signature, userId, currentGroupId, content);
                    break;
                    
                case 'edit_section_select':
                    await handleEditSectionSelect(message, replyTo, senderName, signature, userId, currentGroupId, content);
                    break;
                    
                case 'edit_section':
                    await handleEditSection(message, replyTo, senderName, signature, userId, currentGroupId, content);
                    break;
                    
                case 'delete_section_select':
                    await handleDeleteSectionSelect(message, replyTo, senderName, signature, userId, currentGroupId, content);
                    break;
                    
                case 'classes_action':
                    await handleClassesAction(message, replyTo, senderName, signature, userId, currentGroupId, content);
                    break;
                    
                case 'add_class':
                    await handleAddClass(message, replyTo, senderName, signature, userId, currentGroupId, content);
                    break;
                    
                case 'edit_class_select':
                    await handleEditClassSelect(message, replyTo, senderName, signature, userId, currentGroupId, content);
                    break;
                    
                case 'edit_class':
                    await handleEditClass(message, replyTo, senderName, signature, userId, currentGroupId, content);
                    break;
                    
                case 'delete_class_select':
                    await handleDeleteClassSelect(message, replyTo, senderName, signature, userId, currentGroupId, content);
                    break;
                    
                case 'groups_action':
                    await handleGroupsAction(message, replyTo, senderName, signature, userId, currentGroupId, content);
                    break;
                    
                case 'add_group':
                    await handleAddGroup(message, replyTo, senderName, signature, userId, currentGroupId, content);
                    break;
                    
                case 'edit_group_select':
                    await handleEditGroupSelect(message, replyTo, senderName, signature, userId, currentGroupId, content);
                    break;
                    
                case 'edit_group':
                    await handleEditGroup(message, replyTo, senderName, signature, userId, currentGroupId, content);
                    break;
                    
                case 'delete_group_select':
                    await handleDeleteGroupSelect(message, replyTo, senderName, signature, userId, currentGroupId, content);
                    break;
                    
                case 'professors_action':
                    await handleProfessorsAction(message, replyTo, senderName, signature, userId, currentGroupId, content);
                    break;
                    
                case 'add_professor':
                    await handleAddProfessor(message, replyTo, senderName, signature, userId, currentGroupId, content);
                    break;
                    
                case 'edit_professor_select':
                    await handleEditProfessorSelect(message, replyTo, senderName, signature, userId, currentGroupId, content);
                    break;
                    
                case 'edit_professor':
                    await handleEditProfessor(message, replyTo, senderName, signature, userId, currentGroupId, content);
                    break;
                    
                case 'delete_professor_select':
                    await handleDeleteProfessorSelect(message, replyTo, senderName, signature, userId, currentGroupId, content);
                    break;
                    
                case 'subjects_action':
                    await handleSubjectsAction(message, replyTo, senderName, signature, userId, currentGroupId, content);
                    break;
                    
                case 'add_subject':
                    await handleAddSubject(message, replyTo, senderName, signature, userId, currentGroupId, content);
                    break;
                    
                case 'edit_subject_select':
                    await handleEditSubjectSelect(message, replyTo, senderName, signature, userId, currentGroupId, content);
                    break;
                    
                case 'edit_subject':
                    await handleEditSubject(message, replyTo, senderName, signature, userId, currentGroupId, content);
                    break;
                    
                case 'delete_subject_select':
                    await handleDeleteSubjectSelect(message, replyTo, senderName, signature, userId, currentGroupId, content);
                    break;
                    
                case 'confirm_delete_section':
                case 'confirm_delete_class':
                case 'confirm_delete_group':
                case 'confirm_delete_professor':
                case 'confirm_delete_subject':
                    await handleConfirmDelete(message, replyTo, senderName, signature, userId, currentGroupId, content, state.step);
                    break;
            }
        }
    } catch (error) {
        console.error('[âŒ] Error in message handler:', error);
    }
});

// Helper functions for sections management
async function handleSectionsManagement(message, replyTo, senderName, signature, userId, currentGroupId) {
    await message.react('ğŸ“‹');
    
    let sectionsList = "ğŸ“‹ *Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø´Ø¹Ø¨*\n\n";
    if (sections.size === 0) {
        sectionsList += "Ù„Ø§ ØªÙˆØ¬Ø¯ Ø´Ø¹Ø¨ Ù…Ø¶Ø§ÙØ© Ø¨Ø¹Ø¯.";
    } else {
        let index = 1;
        for (const [id, name] of sections) {
            sectionsList += `${index}. ${name} (ID: ${id})\n`;
            index++;
        }
    }
    
    await client.sendMessage(replyTo, `
${sectionsList}

Ù…Ø§Ø°Ø§ ØªØ±ÙŠØ¯ Ø£Ù† ØªÙØ¹Ù„ØŸ

1. Ø¹Ø±Ø¶ Ø§Ù„Ø´Ø¹Ø¨
2. Ø¥Ø¶Ø§ÙØ© Ø´Ø¹Ø¨Ø© Ø¬Ø¯ÙŠØ¯Ø©
3. ØªØ¹Ø¯ÙŠÙ„ Ø´Ø¹Ø¨Ø©
4. Ø­Ø°Ù Ø´Ø¹Ø¨Ø©

ğŸ’¡ Ø£Ø±Ø³Ù„ Ø±Ù‚Ù… Ø§Ù„Ø®ÙŠØ§Ø± Ø£Ùˆ *Ø¥Ù„ØºØ§Ø¡* Ù„Ù„Ø®Ø±ÙˆØ¬${signature}
    `);
    
    userState.set(userId, { 
        step: 'sections_action', 
        timestamp: Date.now() 
    });
}

async function handleSectionsAction(message, replyTo, senderName, signature, userId, currentGroupId, content) {
    if (content === '1') { // Display sections
        let sectionsList = "ğŸ“‹ *Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø´Ø¹Ø¨*\n\n";
        if (sections.size === 0) {
            sectionsList += "Ù„Ø§ ØªÙˆØ¬Ø¯ Ø´Ø¹Ø¨ Ù…Ø¶Ø§ÙØ© Ø¨Ø¹Ø¯.";
        } else {
            let index = 1;
            for (const [id, name] of sections) {
                sectionsList += `${index}. ${name} (ID: ${id})\n`;
                index++;
            }
        }
        
        await client.sendMessage(replyTo, `${sectionsList}${signature}`);
        userState.delete(userId);
    } else if (content === '2') { // Add section
        await client.sendMessage(replyTo, `
ğŸ“ *Ø¥Ø¶Ø§ÙØ© Ø´Ø¹Ø¨Ø© Ø¬Ø¯ÙŠØ¯Ø©*

ÙŠØ±Ø¬Ù‰ Ø¥Ø±Ø³Ø§Ù„ Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„Ø´Ø¹Ø¨Ø© Ø¨Ø§Ù„ØªÙ†Ø³ÙŠÙ‚ Ø§Ù„ØªØ§Ù„ÙŠ:
Ø§Ø³Ù… Ø§Ù„Ø´Ø¹Ø¨Ø©: [Ø§Ø³Ù… Ø§Ù„Ø´Ø¹Ø¨Ø©]
Ù…Ø¹Ø±Ù Ø§Ù„Ø´Ø¹Ø¨Ø©: [Ù…Ø¹Ø±Ù Ø§Ù„Ø´Ø¹Ø¨Ø©]

ğŸ’¡ Ù…Ø«Ø§Ù„:
Ø§Ø³Ù… Ø§Ù„Ø´Ø¹Ø¨Ø©: Ø´Ø¹Ø¨Ø© Ø§Ù„Ø¹Ù„ÙˆÙ…
Ù…Ø¹Ø±Ù Ø§Ù„Ø´Ø¹Ø¨Ø©: sci

ğŸ’¡ Ø£Ø±Ø³Ù„ *Ø¥Ù„ØºØ§Ø¡* Ù„Ù„Ø®Ø±ÙˆØ¬${signature}
        `);
        
        userState.set(userId, { 
            step: 'add_section', 
            timestamp: Date.now() 
        });
    } else if (content === '3') { // Edit section
        if (sections.size === 0) {
            await client.sendMessage(replyTo, `âš ï¸ Ù„Ø§ ØªÙˆØ¬Ø¯ Ø´Ø¹Ø¨ Ù„Ù„ØªØ¹Ø¯ÙŠÙ„${signature}`);
            userState.delete(userId);
            return;
        }
        
        let sectionsList = "ğŸ“ *Ø§Ø®ØªØ± Ø´Ø¹Ø¨Ø© Ù„Ù„ØªØ¹Ø¯ÙŠÙ„*\n\n";
        let index = 1;
        for (const [id, name] of sections) {
            sectionsList += `${index}. ${name} (ID: ${id})\n`;
            index++;
        }
        
        await client.sendMessage(replyTo, `
${sectionsList}

ğŸ’¡ Ø£Ø±Ø³Ù„ Ø±Ù‚Ù… Ø§Ù„Ø´Ø¹Ø¨Ø© Ø£Ùˆ *Ø¥Ù„ØºØ§Ø¡* Ù„Ù„Ø®Ø±ÙˆØ¬${signature}
        `);
        
        userState.set(userId, { 
            step: 'edit_section_select', 
            timestamp: Date.now() 
        });
    } else if (content === '4') { // Delete section
        if (sections.size === 0) {
            await client.sendMessage(replyTo, `âš ï¸ Ù„Ø§ ØªÙˆØ¬Ø¯ Ø´Ø¹Ø¨ Ù„Ù„Ø­Ø°Ù${signature}`);
            userState.delete(userId);
            return;
        }
        
        let sectionsList = "ğŸ—‘ï¸ *Ø§Ø®ØªØ± Ø´Ø¹Ø¨Ø© Ù„Ù„Ø­Ø°Ù*\n\n";
        let index = 1;
        for (const [id, name] of sections) {
            sectionsList += `${index}. ${name} (ID: ${id})\n`;
            index++;
        }
        
        await client.sendMessage(replyTo, `
${sectionsList}

âš ï¸ ØªØ­Ø°ÙŠØ±: Ø³ÙŠØªÙ… Ø­Ø°Ù Ø§Ù„Ø´Ø¹Ø¨Ø© ÙˆØ¬Ù…ÙŠØ¹ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ø±ØªØ¨Ø·Ø© Ø¨Ù‡Ø§!

ğŸ’¡ Ø£Ø±Ø³Ù„ Ø±Ù‚Ù… Ø§Ù„Ø´Ø¹Ø¨Ø© Ø£Ùˆ *Ø¥Ù„ØºØ§Ø¡* Ù„Ù„Ø®Ø±ÙˆØ¬${signature}
        `);
        
        userState.set(userId, { 
            step: 'delete_section_select', 
            timestamp: Date.now() 
        });
    } else {
        await client.sendMessage(replyTo, `âš ï¸ Ø®ÙŠØ§Ø± ØºÙŠØ± ØµØ§Ù„Ø­. ÙŠØ±Ø¬Ù‰ Ø¥Ø±Ø³Ø§Ù„ Ø±Ù‚Ù… Ù…Ù† 1 Ø¥Ù„Ù‰ 4${signature}`);
    }
}

async function handleAddSection(message, replyTo, senderName, signature, userId, currentGroupId, content) {
    const nameMatch = content.match(/Ø§Ø³Ù… Ø§Ù„Ø´Ø¹Ø¨Ø©:\s*(.+)/i);
    const idMatch = content.match(/Ù…Ø¹Ø±Ù Ø§Ù„Ø´Ø¹Ø¨Ø©:\s*(.+)/i);
    
    if (!nameMatch || !idMatch) {
        await client.sendMessage(replyTo, `âš ï¸ ØªÙ†Ø³ÙŠÙ‚ ØºÙŠØ± ØµØ§Ù„Ø­. ÙŠØ±Ø¬Ù‰ Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø¨Ø§Ù„ØªÙ†Ø³ÙŠÙ‚ Ø§Ù„Ù…Ø·Ù„ÙˆØ¨${signature}`);
        return;
    }
    
    const name = nameMatch[1].trim();
    const id = idMatch[1].trim();
    
    if (sections.has(id)) {
        await client.sendMessage(replyTo, `âš ï¸ Ù…Ø¹Ø±Ù Ø§Ù„Ø´Ø¹Ø¨Ø© "${id}" Ù…ÙˆØ¬ÙˆØ¯ Ø¨Ø§Ù„ÙØ¹Ù„${signature}`);
        userState.delete(userId);
        return;
    }
    
    sections.set(id, name);
    await saveSections();
    
    await client.sendMessage(replyTo, `âœ… ØªÙ…Øª Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ø´Ø¹Ø¨Ø© "${name}" Ø¨Ù†Ø¬Ø§Ø­${signature}`);
    userState.delete(userId);
}

async function handleEditSectionSelect(message, replyTo, senderName, signature, userId, currentGroupId, content) {
    const index = parseInt(content) - 1;
    if (isNaN(index) || index < 0 || index >= sections.size) {
        await client.sendMessage(replyTo, `âš ï¸ Ø±Ù‚Ù… ØºÙŠØ± ØµØ§Ù„Ø­. ÙŠØ±Ø¬Ù‰ Ø¥Ø±Ø³Ø§Ù„ Ø±Ù‚Ù… Ø´Ø¹Ø¨Ø© ØµØ­ÙŠØ­${signature}`);
        return;
    }
    
    const sectionId = Array.from(sections.keys())[index];
    const sectionName = sections.get(sectionId);
    
    await client.sendMessage(replyTo, `
ğŸ“ *ØªØ¹Ø¯ÙŠÙ„ Ø§Ù„Ø´Ø¹Ø¨Ø©*

Ø§Ù„Ø´Ø¹Ø¨Ø© Ø§Ù„Ø­Ø§Ù„ÙŠØ©: ${sectionName} (ID: ${sectionId})

ÙŠØ±Ø¬Ù‰ Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„Ø¬Ø¯ÙŠØ¯Ø© Ø¨Ø§Ù„ØªÙ†Ø³ÙŠÙ‚ Ø§Ù„ØªØ§Ù„ÙŠ:
Ø§Ø³Ù… Ø§Ù„Ø´Ø¹Ø¨Ø©: [Ø§Ù„Ø§Ø³Ù… Ø§Ù„Ø¬Ø¯ÙŠØ¯]
Ù…Ø¹Ø±Ù Ø§Ù„Ø´Ø¹Ø¨Ø©: [Ø§Ù„Ù…Ø¹Ø±Ù Ø§Ù„Ø¬Ø¯ÙŠØ¯]

ğŸ’¡ Ø£Ø±Ø³Ù„ *Ø¥Ù„ØºØ§Ø¡* Ù„Ù„Ø®Ø±ÙˆØ¬${signature}
    `);
    
    userState.set(userId, { 
        step: 'edit_section', 
        timestamp: Date.now(),
        sectionId: sectionId
    });
}

async function handleEditSection(message, replyTo, senderName, signature, userId, currentGroupId, content) {
    const nameMatch = content.match(/Ø§Ø³Ù… Ø§Ù„Ø´Ø¹Ø¨Ø©:\s*(.+)/i);
    const idMatch = content.match(/Ù…Ø¹Ø±Ù Ø§Ù„Ø´Ø¹Ø¨Ø©:\s*(.+)/i);
    
    if (!nameMatch || !idMatch) {
        await client.sendMessage(replyTo, `âš ï¸ ØªÙ†Ø³ÙŠÙ‚ ØºÙŠØ± ØµØ§Ù„Ø­. ÙŠØ±Ø¬Ù‰ Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø¨Ø§Ù„ØªÙ†Ø³ÙŠÙ‚ Ø§Ù„Ù…Ø·Ù„ÙˆØ¨${signature}`);
        return;
    }
    
    const name = nameMatch[1].trim();
    const id = idMatch[1].trim();
    const oldId = userState.get(userId).sectionId;
    
    // Check if new ID already exists and it's not the same as the old one
    if (id !== oldId && sections.has(id)) {
        await client.sendMessage(replyTo, `âš ï¸ Ù…Ø¹Ø±Ù Ø§Ù„Ø´Ø¹Ø¨Ø© "${id}" Ù…ÙˆØ¬ÙˆØ¯ Ø¨Ø§Ù„ÙØ¹Ù„${signature}`);
        userState.delete(userId);
        return;
    }
    
    // Delete old entry if ID is changing
    if (id !== oldId) {
        sections.delete(oldId);
    }
    
    sections.set(id, name);
    await saveSections();
    
    await client.sendMessage(replyTo, `âœ… ØªÙ… ØªØ¹Ø¯ÙŠÙ„ Ø§Ù„Ø´Ø¹Ø¨Ø© Ø¨Ù†Ø¬Ø§Ø­${signature}`);
    userState.delete(userId);
}

async function handleDeleteSectionSelect(message, replyTo, senderName, signature, userId, currentGroupId, content) {
    const index = parseInt(content) - 1;
    if (isNaN(index) || index < 0 || index >= sections.size) {
        await client.sendMessage(replyTo, `âš ï¸ Ø±Ù‚Ù… ØºÙŠØ± ØµØ§Ù„Ø­. ÙŠØ±Ø¬Ù‰ Ø¥Ø±Ø³Ø§Ù„ Ø±Ù‚Ù… Ø´Ø¹Ø¨Ø© ØµØ­ÙŠØ­${signature}`);
        return;
    }
    
    const sectionId = Array.from(sections.keys())[index];
    const sectionName = sections.get(sectionId);
    
    // Confirm deletion
    await client.sendMessage(replyTo, `
âš ï¸ *ØªØ£ÙƒÙŠØ¯ Ø§Ù„Ø­Ø°Ù*

Ù‡Ù„ Ø£Ù†Øª Ù…ØªØ£ÙƒØ¯ Ù…Ù† Ø­Ø°Ù Ø§Ù„Ø´Ø¹Ø¨Ø© "${sectionName}"ØŸ

Ù‡Ø°Ø§ Ø§Ù„Ø¥Ø¬Ø±Ø§Ø¡ Ù„Ø§ ÙŠÙ…ÙƒÙ† Ø§Ù„ØªØ±Ø§Ø¬Ø¹ Ø¹Ù†Ù‡.

ğŸ’¡ Ø£Ø±Ø³Ù„ *ØªØ£ÙƒÙŠØ¯* Ù„Ù„Ø­Ø°Ù Ø£Ùˆ *Ø¥Ù„ØºØ§Ø¡* Ù„Ù„Ø¥Ù„ØºØ§Ø¡${signature}
    `);
    
    userState.set(userId, { 
        step: 'confirm_delete_section', 
        timestamp: Date.now(),
        sectionId: sectionId,
        sectionName: sectionName
    });
}

// Helper functions for classes management
async function handleClassesManagement(message, replyTo, senderName, signature, userId, currentGroupId) {
    await message.react('ğŸ“‹');
    
    let classesList = "ğŸ“‹ *Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„ÙØµÙˆÙ„*\n\n";
    if (classes.size === 0) {
        classesList += "Ù„Ø§ ØªÙˆØ¬Ø¯ ÙØµÙˆÙ„ Ù…Ø¶Ø§ÙØ© Ø¨Ø¹Ø¯.";
    } else {
        let index = 1;
        for (const [id, name] of classes) {
            classesList += `${index}. ${name} (ID: ${id})\n`;
            index++;
        }
    }
    
    await client.sendMessage(replyTo, `
${classesList}

Ù…Ø§Ø°Ø§ ØªØ±ÙŠØ¯ Ø£Ù† ØªÙØ¹Ù„ØŸ

1. Ø¹Ø±Ø¶ Ø§Ù„ÙØµÙˆÙ„
2. Ø¥Ø¶Ø§ÙØ© ÙØµÙ„ Ø¬Ø¯ÙŠØ¯
3. ØªØ¹Ø¯ÙŠÙ„ ÙØµÙ„
4. Ø­Ø°Ù ÙØµÙ„

ğŸ’¡ Ø£Ø±Ø³Ù„ Ø±Ù‚Ù… Ø§Ù„Ø®ÙŠØ§Ø± Ø£Ùˆ *Ø¥Ù„ØºØ§Ø¡* Ù„Ù„Ø®Ø±ÙˆØ¬${signature}
    `);
    
    userState.set(userId, { 
        step: 'classes_action', 
        timestamp: Date.now() 
    });
}

async function handleClassesAction(message, replyTo, senderName, signature, userId, currentGroupId, content) {
    if (content === '1') { // Display classes
        let classesList = "ğŸ“‹ *Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„ÙØµÙˆÙ„*\n\n";
        if (classes.size === 0) {
            classesList += "Ù„Ø§ ØªÙˆØ¬Ø¯ ÙØµÙˆÙ„ Ù…Ø¶Ø§ÙØ© Ø¨Ø¹Ø¯.";
        } else {
            let index = 1;
            for (const [id, name] of classes) {
                classesList += `${index}. ${name} (ID: ${id})\n`;
                index++;
            }
        }
        
        await client.sendMessage(replyTo, `${classesList}${signature}`);
        userState.delete(userId);
    } else if (content === '2') { // Add class
        await client.sendMessage(replyTo, `
ğŸ“ *Ø¥Ø¶Ø§ÙØ© ÙØµÙ„ Ø¬Ø¯ÙŠØ¯*

ÙŠØ±Ø¬Ù‰ Ø¥Ø±Ø³Ø§Ù„ Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„ÙØµÙ„ Ø¨Ø§Ù„ØªÙ†Ø³ÙŠÙ‚ Ø§Ù„ØªØ§Ù„ÙŠ:
Ø§Ø³Ù… Ø§Ù„ÙØµÙ„: [Ø§Ø³Ù… Ø§Ù„ÙØµÙ„]
Ù…Ø¹Ø±Ù Ø§Ù„ÙØµÙ„: [Ù…Ø¹Ø±Ù Ø§Ù„ÙØµÙ„]

ğŸ’¡ Ù…Ø«Ø§Ù„:
Ø§Ø³Ù… Ø§Ù„ÙØµÙ„: Ø§Ù„ÙØµÙ„ Ø§Ù„Ø£ÙˆÙ„
Ù…Ø¹Ø±Ù Ø§Ù„ÙØµÙ„: class1

ğŸ’¡ Ø£Ø±Ø³Ù„ *Ø¥Ù„ØºØ§Ø¡* Ù„Ù„Ø®Ø±ÙˆØ¬${signature}
        `);
        
        userState.set(userId, { 
            step: 'add_class', 
            timestamp: Date.now() 
        });
    } else if (content === '3') { // Edit class
        if (classes.size === 0) {
            await client.sendMessage(replyTo, `âš ï¸ Ù„Ø§ ØªÙˆØ¬Ø¯ ÙØµÙˆÙ„ Ù„Ù„ØªØ¹Ø¯ÙŠÙ„${signature}`);
            userState.delete(userId);
            return;
        }
        
        let classesList = "ğŸ“ *Ø§Ø®ØªØ± ÙØµÙ„Ø§Ù‹ Ù„Ù„ØªØ¹Ø¯ÙŠÙ„*\n\n";
        let index = 1;
        for (const [id, name] of classes) {
            classesList += `${index}. ${name} (ID: ${id})\n`;
            index++;
        }
        
        await client.sendMessage(replyTo, `
${classesList}

ğŸ’¡ Ø£Ø±Ø³Ù„ Ø±Ù‚Ù… Ø§Ù„ÙØµÙ„ Ø£Ùˆ *Ø¥Ù„ØºØ§Ø¡* Ù„Ù„Ø®Ø±ÙˆØ¬${signature}
        `);
        
        userState.set(userId, { 
            step: 'edit_class_select', 
            timestamp: Date.now() 
        });
    } else if (content === '4') { // Delete class
        if (classes.size === 0) {
            await client.sendMessage(replyTo, `âš ï¸ Ù„Ø§ ØªÙˆØ¬Ø¯ ÙØµÙˆÙ„ Ù„Ù„Ø­Ø°Ù${signature}`);
            userState.delete(userId);
            return;
        }
        
        let classesList = "ğŸ—‘ï¸ *Ø§Ø®ØªØ± ÙØµÙ„Ø§Ù‹ Ù„Ù„Ø­Ø°Ù*\n\n";
        let index = 1;
        for (const [id, name] of classes) {
            classesList += `${index}. ${name} (ID: ${id})\n`;
            index++;
        }
        
        await client.sendMessage(replyTo, `
${classesList}

âš ï¸ ØªØ­Ø°ÙŠØ±: Ø³ÙŠØªÙ… Ø­Ø°Ù Ø§Ù„ÙØµÙ„ ÙˆØ¬Ù…ÙŠØ¹ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ø±ØªØ¨Ø·Ø© Ø¨Ù‡!

ğŸ’¡ Ø£Ø±Ø³Ù„ Ø±Ù‚Ù… Ø§Ù„ÙØµÙ„ Ø£Ùˆ *Ø¥Ù„ØºØ§Ø¡* Ù„Ù„Ø®Ø±ÙˆØ¬${signature}
        `);
        
        userState.set(userId, { 
            step: 'delete_class_select', 
            timestamp: Date.now() 
        });
    } else {
        await client.sendMessage(replyTo, `âš ï¸ Ø®ÙŠØ§Ø± ØºÙŠØ± ØµØ§Ù„Ø­. ÙŠØ±Ø¬Ù‰ Ø¥Ø±Ø³Ø§Ù„ Ø±Ù‚Ù… Ù…Ù† 1 Ø¥Ù„Ù‰ 4${signature}`);
    }
}

async function handleAddClass(message, replyTo, senderName, signature, userId, currentGroupId, content) {
    const nameMatch = content.match(/Ø§Ø³Ù… Ø§Ù„ÙØµÙ„:\s*(.+)/i);
    const idMatch = content.match(/Ù…Ø¹Ø±Ù Ø§Ù„ÙØµÙ„:\s*(.+)/i);
    
    if (!nameMatch || !idMatch) {
        await client.sendMessage(replyTo, `âš ï¸ ØªÙ†Ø³ÙŠÙ‚ ØºÙŠØ± ØµØ§Ù„Ø­. ÙŠØ±Ø¬Ù‰ Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø¨Ø§Ù„ØªÙ†Ø³ÙŠÙ‚ Ø§Ù„Ù…Ø·Ù„ÙˆØ¨${signature}`);
        return;
    }
    
    const name = nameMatch[1].trim();
    const id = idMatch[1].trim();
    
    if (classes.has(id)) {
        await client.sendMessage(replyTo, `âš ï¸ Ù…Ø¹Ø±Ù Ø§Ù„ÙØµÙ„ "${id}" Ù…ÙˆØ¬ÙˆØ¯ Ø¨Ø§Ù„ÙØ¹Ù„${signature}`);
        userState.delete(userId);
        return;
    }
    
    classes.set(id, name);
    await saveClasses();
    
    await client.sendMessage(replyTo, `âœ… ØªÙ…Øª Ø¥Ø¶Ø§ÙØ© Ø§Ù„ÙØµÙ„ "${name}" Ø¨Ù†Ø¬Ø§Ø­${signature}`);
    userState.delete(userId);
}

async function handleEditClassSelect(message, replyTo, senderName, signature, userId, currentGroupId, content) {
    const index = parseInt(content) - 1;
    if (isNaN(index) || index < 0 || index >= classes.size) {
        await client.sendMessage(replyTo, `âš ï¸ Ø±Ù‚Ù… ØºÙŠØ± ØµØ§Ù„Ø­. ÙŠØ±Ø¬Ù‰ Ø¥Ø±Ø³Ø§Ù„ Ø±Ù‚Ù… ÙØµÙ„ ØµØ­ÙŠØ­${signature}`);
        return;
    }
    
    const classId = Array.from(classes.keys())[index];
    const className = classes.get(classId);
    
    await client.sendMessage(replyTo, `
ğŸ“ *ØªØ¹Ø¯ÙŠÙ„ Ø§Ù„ÙØµÙ„*

Ø§Ù„ÙØµÙ„ Ø§Ù„Ø­Ø§Ù„ÙŠ: ${className} (ID: ${classId})

ÙŠØ±Ø¬Ù‰ Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„Ø¬Ø¯ÙŠØ¯Ø© Ø¨Ø§Ù„ØªÙ†Ø³ÙŠÙ‚ Ø§Ù„ØªØ§Ù„ÙŠ:
Ø§Ø³Ù… Ø§Ù„ÙØµÙ„: [Ø§Ù„Ø§Ø³Ù… Ø§Ù„Ø¬Ø¯ÙŠØ¯]
Ù…Ø¹Ø±Ù Ø§Ù„ÙØµÙ„: [Ø§Ù„Ù…Ø¹Ø±Ù Ø§Ù„Ø¬Ø¯ÙŠØ¯]

ğŸ’¡ Ø£Ø±Ø³Ù„ *Ø¥Ù„ØºØ§Ø¡* Ù„Ù„Ø®Ø±ÙˆØ¬${signature}
    `);
    
    userState.set(userId, { 
        step: 'edit_class', 
        timestamp: Date.now(),
        classId: classId
    });
}

async function handleEditClass(message, replyTo, senderName, signature, userId, currentGroupId, content) {
    const nameMatch = content.match(/Ø§Ø³Ù… Ø§Ù„ÙØµÙ„:\s*(.+)/i);
    const idMatch = content.match(/Ù…Ø¹Ø±Ù Ø§Ù„ÙØµÙ„:\s*(.+)/i);
    
    if (!nameMatch || !idMatch) {
        await client.sendMessage(replyTo, `âš ï¸ ØªÙ†Ø³ÙŠÙ‚ ØºÙŠØ± ØµØ§Ù„Ø­. ÙŠØ±Ø¬Ù‰ Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø¨Ø§Ù„ØªÙ†Ø³ÙŠÙ‚ Ø§Ù„Ù…Ø·Ù„ÙˆØ¨${signature}`);
        return;
    }
    
    const name = nameMatch[1].trim();
    const id = idMatch[1].trim();
    const oldId = userState.get(userId).classId;
    
    // Check if new ID already exists and it's not the same as the old one
    if (id !== oldId && classes.has(id)) {
        await client.sendMessage(replyTo, `âš ï¸ Ù…Ø¹Ø±Ù Ø§Ù„ÙØµÙ„ "${id}" Ù…ÙˆØ¬ÙˆØ¯ Ø¨Ø§Ù„ÙØ¹Ù„${signature}`);
        userState.delete(userId);
        return;
    }
    
    // Delete old entry if ID is changing
    if (id !== oldId) {
        classes.delete(oldId);
    }
    
    classes.set(id, name);
    await saveClasses();
    
    await client.sendMessage(replyTo, `âœ… ØªÙ… ØªØ¹Ø¯ÙŠÙ„ Ø§Ù„ÙØµÙ„ Ø¨Ù†Ø¬Ø§Ø­${signature}`);
    userState.delete(userId);
}

async function handleDeleteClassSelect(message, replyTo, senderName, signature, userId, currentGroupId, content) {
    const index = parseInt(content) - 1;
    if (isNaN(index) || index < 0 || index >= classes.size) {
        await client.sendMessage(replyTo, `âš ï¸ Ø±Ù‚Ù… ØºÙŠØ± ØµØ§Ù„Ø­. ÙŠØ±Ø¬Ù‰ Ø¥Ø±Ø³Ø§Ù„ Ø±Ù‚Ù… ÙØµÙ„ ØµØ­ÙŠØ­${signature}`);
        return;
    }
    
    const classId = Array.from(classes.keys())[index];
    const className = classes.get(classId);
    
    // Confirm deletion
    await client.sendMessage(replyTo, `
âš ï¸ *ØªØ£ÙƒÙŠØ¯ Ø§Ù„Ø­Ø°Ù*

Ù‡Ù„ Ø£Ù†Øª Ù…ØªØ£ÙƒØ¯ Ù…Ù† Ø­Ø°Ù Ø§Ù„ÙØµÙ„ "${className}"ØŸ

Ù‡Ø°Ø§ Ø§Ù„Ø¥Ø¬Ø±Ø§Ø¡ Ù„Ø§ ÙŠÙ…ÙƒÙ† Ø§Ù„ØªØ±Ø§Ø¬Ø¹ Ø¹Ù†Ù‡.

ğŸ’¡ Ø£Ø±Ø³Ù„ *ØªØ£ÙƒÙŠØ¯* Ù„Ù„Ø­Ø°Ù Ø£Ùˆ *Ø¥Ù„ØºØ§Ø¡* Ù„Ù„Ø¥Ù„ØºØ§Ø¡${signature}
    `);
    
    userState.set(userId, { 
        step: 'confirm_delete_class', 
        timestamp: Date.now(),
        classId: classId,
        className: className
    });
}

// Helper functions for groups management
async function handleGroupsManagement(message, replyTo, senderName, signature, userId, currentGroupId) {
    await message.react('ğŸ“‹');
    
    let groupsList = "ğŸ“‹ *Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø£ÙÙˆØ§Ø¬*\n\n";
    if (groupsData.size === 0) {
        groupsList += "Ù„Ø§ ØªÙˆØ¬Ø¯ Ø£ÙÙˆØ§Ø¬ Ù…Ø¶Ø§ÙØ© Ø¨Ø¹Ø¯.";
    } else {
        let index = 1;
        for (const [id, name] of groupsData) {
            groupsList += `${index}. ${name} (ID: ${id})\n`;
            index++;
        }
    }
    
    await client.sendMessage(replyTo, `
${groupsList}

Ù…Ø§Ø°Ø§ ØªØ±ÙŠØ¯ Ø£Ù† ØªÙØ¹Ù„ØŸ

1. Ø¹Ø±Ø¶ Ø§Ù„Ø£ÙÙˆØ§Ø¬
2. Ø¥Ø¶Ø§ÙØ© ÙÙˆØ¬ Ø¬Ø¯ÙŠØ¯
3. ØªØ¹Ø¯ÙŠÙ„ ÙÙˆØ¬
4. Ø­Ø°Ù ÙÙˆØ¬

ğŸ’¡ Ø£Ø±Ø³Ù„ Ø±Ù‚Ù… Ø§Ù„Ø®ÙŠØ§Ø± Ø£Ùˆ *Ø¥Ù„ØºØ§Ø¡* Ù„Ù„Ø®Ø±ÙˆØ¬${signature}
    `);
    
    userState.set(userId, { 
        step: 'groups_action', 
        timestamp: Date.now() 
    });
}

async function handleGroupsAction(message, replyTo, senderName, signature, userId, currentGroupId, content) {
    if (content === '1') { // Display groups
        let groupsList = "ğŸ“‹ *Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø£ÙÙˆØ§Ø¬*\n\n";
        if (groupsData.size === 0) {
            groupsList += "Ù„Ø§ ØªÙˆØ¬Ø¯ Ø£ÙÙˆØ§Ø¬ Ù…Ø¶Ø§ÙØ© Ø¨Ø¹Ø¯.";
        } else {
            let index = 1;
            for (const [id, name] of groupsData) {
                groupsList += `${index}. ${name} (ID: ${id})\n`;
                index++;
            }
        }
        
        await client.sendMessage(replyTo, `${groupsList}${signature}`);
        userState.delete(userId);
    } else if (content === '2') { // Add group
        await client.sendMessage(replyTo, `
ğŸ“ *Ø¥Ø¶Ø§ÙØ© ÙÙˆØ¬ Ø¬Ø¯ÙŠØ¯*

ÙŠØ±Ø¬Ù‰ Ø¥Ø±Ø³Ø§Ù„ Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„ÙÙˆØ¬ Ø¨Ø§Ù„ØªÙ†Ø³ÙŠÙ‚ Ø§Ù„ØªØ§Ù„ÙŠ:
Ø§Ø³Ù… Ø§Ù„ÙÙˆØ¬: [Ø§Ø³Ù… Ø§Ù„ÙÙˆØ¬]
Ù…Ø¹Ø±Ù Ø§Ù„ÙÙˆØ¬: [Ù…Ø¹Ø±Ù Ø§Ù„ÙÙˆØ¬]

ğŸ’¡ Ù…Ø«Ø§Ù„:
Ø§Ø³Ù… Ø§Ù„ÙÙˆØ¬: Ø§Ù„ÙÙˆØ¬ Ø§Ù„Ø£ÙˆÙ„
Ù…Ø¹Ø±Ù Ø§Ù„ÙÙˆØ¬: group1

ğŸ’¡ Ø£Ø±Ø³Ù„ *Ø¥Ù„ØºØ§Ø¡* Ù„Ù„Ø®Ø±ÙˆØ¬${signature}
        `);
        
        userState.set(userId, { 
            step: 'add_group', 
            timestamp: Date.now() 
        });
    } else if (content === '3') { // Edit group
        if (groupsData.size === 0) {
            await client.sendMessage(replyTo, `âš ï¸ Ù„Ø§ ØªÙˆØ¬Ø¯ Ø£ÙÙˆØ§Ø¬ Ù„Ù„ØªØ¹Ø¯ÙŠÙ„${signature}`);
            userState.delete(userId);
            return;
        }
        
        let groupsList = "ğŸ“ *Ø§Ø®ØªØ± ÙÙˆØ¬Ø§Ù‹ Ù„Ù„ØªØ¹Ø¯ÙŠÙ„*\n\n";
        let index = 1;
        for (const [id, name] of groupsData) {
            groupsList += `${index}. ${name} (ID: ${id})\n`;
            index++;
        }
        
        await client.sendMessage(replyTo, `
${groupsList}

ğŸ’¡ Ø£Ø±Ø³Ù„ Ø±Ù‚Ù… Ø§Ù„ÙÙˆØ¬ Ø£Ùˆ *Ø¥Ù„ØºØ§Ø¡* Ù„Ù„Ø®Ø±ÙˆØ¬${signature}
        `);
        
        userState.set(userId, { 
            step: 'edit_group_select', 
            timestamp: Date.now() 
        });
    } else if (content === '4') { // Delete group
        if (groupsData.size === 0) {
            await client.sendMessage(replyTo, `âš ï¸ Ù„Ø§ ØªÙˆØ¬Ø¯ Ø£ÙÙˆØ§Ø¬ Ù„Ù„Ø­Ø°Ù${signature}`);
            userState.delete(userId);
            return;
        }
        
        let groupsList = "ğŸ—‘ï¸ *Ø§Ø®ØªØ± ÙÙˆØ¬Ø§Ù‹ Ù„Ù„Ø­Ø°Ù*\n\n";
        let index = 1;
        for (const [id, name] of groupsData) {
            groupsList += `${index}. ${name} (ID: ${id})\n`;
            index++;
        }
        
        await client.sendMessage(replyTo, `
${groupsList}

âš ï¸ ØªØ­Ø°ÙŠØ±: Ø³ÙŠØªÙ… Ø­Ø°Ù Ø§Ù„ÙÙˆØ¬ ÙˆØ¬Ù…ÙŠØ¹ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ø±ØªØ¨Ø·Ø© Ø¨Ù‡!

ğŸ’¡ Ø£Ø±Ø³Ù„ Ø±Ù‚Ù… Ø§Ù„ÙÙˆØ¬ Ø£Ùˆ *Ø¥Ù„ØºØ§Ø¡* Ù„Ù„Ø®Ø±ÙˆØ¬${signature}
        `);
        
        userState.set(userId, { 
            step: 'delete_group_select', 
            timestamp: Date.now() 
        });
    } else {
        await client.sendMessage(replyTo, `âš ï¸ Ø®ÙŠØ§Ø± ØºÙŠØ± ØµØ§Ù„Ø­. ÙŠØ±Ø¬Ù‰ Ø¥Ø±Ø³Ø§Ù„ Ø±Ù‚Ù… Ù…Ù† 1 Ø¥Ù„Ù‰ 4${signature}`);
    }
}

async function handleAddGroup(message, replyTo, senderName, signature, userId, currentGroupId, content) {
    const nameMatch = content.match(/Ø§Ø³Ù… Ø§Ù„ÙÙˆØ¬:\s*(.+)/i);
    const idMatch = content.match(/Ù…Ø¹Ø±Ù Ø§Ù„ÙÙˆØ¬:\s*(.+)/i);
    
    if (!nameMatch || !idMatch) {
        await client.sendMessage(replyTo, `âš ï¸ ØªÙ†Ø³ÙŠÙ‚ ØºÙŠØ± ØµØ§Ù„Ø­. ÙŠØ±Ø¬Ù‰ Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø¨Ø§Ù„ØªÙ†Ø³ÙŠÙ‚ Ø§Ù„Ù…Ø·Ù„ÙˆØ¨${signature}`);
        return;
    }
    
    const name = nameMatch[1].trim();
    const id = idMatch[1].trim();
    
    if (groupsData.has(id)) {
        await client.sendMessage(replyTo, `âš ï¸ Ù…Ø¹Ø±Ù Ø§Ù„ÙÙˆØ¬ "${id}" Ù…ÙˆØ¬ÙˆØ¯ Ø¨Ø§Ù„ÙØ¹Ù„${signature}`);
        userState.delete(userId);
        return;
    }
    
    groupsData.set(id, name);
    await saveGroups();
    
    await client.sendMessage(replyTo, `âœ… ØªÙ…Øª Ø¥Ø¶Ø§ÙØ© Ø§Ù„ÙÙˆØ¬ "${name}" Ø¨Ù†Ø¬Ø§Ø­${signature}`);
    userState.delete(userId);
}

async function handleEditGroupSelect(message, replyTo, senderName, signature, userId, currentGroupId, content) {
    const index = parseInt(content) - 1;
    if (isNaN(index) || index < 0 || index >= groupsData.size) {
        await client.sendMessage(replyTo, `âš ï¸ Ø±Ù‚Ù… ØºÙŠØ± ØµØ§Ù„Ø­. ÙŠØ±Ø¬Ù‰ Ø¥Ø±Ø³Ø§Ù„ Ø±Ù‚Ù… ÙÙˆØ¬ ØµØ­ÙŠØ­${signature}`);
        return;
    }
    
    const groupId = Array.from(groupsData.keys())[index];
    const groupName = groupsData.get(groupId);
    
    await client.sendMessage(replyTo, `
ğŸ“ *ØªØ¹Ø¯ÙŠÙ„ Ø§Ù„ÙÙˆØ¬*

Ø§Ù„ÙÙˆØ¬ Ø§Ù„Ø­Ø§Ù„ÙŠ: ${groupName} (ID: ${groupId})

ÙŠØ±Ø¬Ù‰ Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„Ø¬Ø¯ÙŠØ¯Ø© Ø¨Ø§Ù„ØªÙ†Ø³ÙŠÙ‚ Ø§Ù„ØªØ§Ù„ÙŠ:
Ø§Ø³Ù… Ø§Ù„ÙÙˆØ¬: [Ø§Ù„Ø§Ø³Ù… Ø§Ù„Ø¬Ø¯ÙŠØ¯]
Ù…Ø¹Ø±Ù Ø§Ù„ÙÙˆØ¬: [Ø§Ù„Ù…Ø¹Ø±Ù Ø§Ù„Ø¬Ø¯ÙŠØ¯]

ğŸ’¡ Ø£Ø±Ø³Ù„ *Ø¥Ù„ØºØ§Ø¡* Ù„Ù„Ø®Ø±ÙˆØ¬${signature}
    `);
    
    userState.set(userId, { 
        step: 'edit_group', 
        timestamp: Date.now(),
        groupId: groupId
    });
}

async function handleEditGroup(message, replyTo, senderName, signature, userId, currentGroupId, content) {
    const nameMatch = content.match(/Ø§Ø³Ù… Ø§Ù„ÙÙˆØ¬:\s*(.+)/i);
    const idMatch = content.match(/Ù…Ø¹Ø±Ù Ø§Ù„ÙÙˆØ¬:\s*(.+)/i);
    
    if (!nameMatch || !idMatch) {
        await client.sendMessage(replyTo, `âš ï¸ ØªÙ†Ø³ÙŠÙ‚ ØºÙŠØ± ØµØ§Ù„Ø­. ÙŠØ±Ø¬Ù‰ Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø¨Ø§Ù„ØªÙ†Ø³ÙŠÙ‚ Ø§Ù„Ù…Ø·Ù„ÙˆØ¨${signature}`);
        return;
    }
    
    const name = nameMatch[1].trim();
    const id = idMatch[1].trim();
    const oldId = userState.get(userId).groupId;
    
    // Check if new ID already exists and it's not the same as the old one
    if (id !== oldId && groupsData.has(id)) {
        await client.sendMessage(replyTo, `âš ï¸ Ù…Ø¹Ø±Ù Ø§Ù„ÙÙˆØ¬ "${id}" Ù…ÙˆØ¬ÙˆØ¯ Ø¨Ø§Ù„ÙØ¹Ù„${signature}`);
        userState.delete(userId);
        return;
    }
    
    // Delete old entry if ID is changing
    if (id !== oldId) {
        groupsData.delete(oldId);
    }
    
    groupsData.set(id, name);
    await saveGroups();
    
    await client.sendMessage(replyTo, `âœ… ØªÙ… ØªØ¹Ø¯ÙŠÙ„ Ø§Ù„ÙÙˆØ¬ Ø¨Ù†Ø¬Ø§Ø­${signature}`);
    userState.delete(userId);
}

async function handleDeleteGroupSelect(message, replyTo, senderName, signature, userId, currentGroupId, content) {
    const index = parseInt(content) - 1;
    if (isNaN(index) || index < 0 || index >= groupsData.size) {
        await client.sendMessage(replyTo, `âš ï¸ Ø±Ù‚Ù… ØºÙŠØ± ØµØ§Ù„Ø­. ÙŠØ±Ø¬Ù‰ Ø¥Ø±Ø³Ø§Ù„ Ø±Ù‚Ù… ÙÙˆØ¬ ØµØ­ÙŠØ­${signature}`);
        return;
    }
    
    const groupId = Array.from(groupsData.keys())[index];
    const groupName = groupsData.get(groupId);
    
    // Confirm deletion
    await client.sendMessage(replyTo, `
âš ï¸ *ØªØ£ÙƒÙŠØ¯ Ø§Ù„Ø­Ø°Ù*

Ù‡Ù„ Ø£Ù†Øª Ù…ØªØ£ÙƒØ¯ Ù…Ù† Ø­Ø°Ù Ø§Ù„ÙÙˆØ¬ "${groupName}"ØŸ

Ù‡Ø°Ø§ Ø§Ù„Ø¥Ø¬Ø±Ø§Ø¡ Ù„Ø§ ÙŠÙ…ÙƒÙ† Ø§Ù„ØªØ±Ø§Ø¬Ø¹ Ø¹Ù†Ù‡.

ğŸ’¡ Ø£Ø±Ø³Ù„ *ØªØ£ÙƒÙŠØ¯* Ù„Ù„Ø­Ø°Ù Ø£Ùˆ *Ø¥Ù„ØºØ§Ø¡* Ù„Ù„Ø¥Ù„ØºØ§Ø¡${signature}
    `);
    
    userState.set(userId, { 
        step: 'confirm_delete_group', 
        timestamp: Date.now(),
        groupId: groupId,
        groupName: groupName
    });
}

// Helper functions for professors management
async function handleProfessorsManagement(message, replyTo, senderName, signature, userId, currentGroupId) {
    await message.react('ğŸ“‹');
    
    let professorsList = "ğŸ“‹ *Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø£Ø³Ø§ØªØ°Ø©*\n\n";
    if (professors.size === 0) {
        professorsList += "Ù„Ø§ ÙŠÙˆØ¬Ø¯ Ø£Ø³Ø§ØªØ°Ø© Ù…Ø¶Ø§ÙÙŠÙ† Ø¨Ø¹Ø¯.";
    } else {
        let index = 1;
        for (const [id, name] of professors) {
            professorsList += `${index}. ${name} (ID: ${id})\n`;
            index++;
        }
    }
    
    await client.sendMessage(replyTo, `
${professorsList}

Ù…Ø§Ø°Ø§ ØªØ±ÙŠØ¯ Ø£Ù† ØªÙØ¹Ù„ØŸ

1. Ø¹Ø±Ø¶ Ø§Ù„Ø£Ø³Ø§ØªØ°Ø©
2. Ø¥Ø¶Ø§ÙØ© Ø£Ø³ØªØ§Ø° Ø¬Ø¯ÙŠØ¯
3. ØªØ¹Ø¯ÙŠÙ„ Ø£Ø³ØªØ§Ø°
4. Ø­Ø°Ù Ø£Ø³ØªØ§Ø°

ğŸ’¡ Ø£Ø±Ø³Ù„ Ø±Ù‚Ù… Ø§Ù„Ø®ÙŠØ§Ø± Ø£Ùˆ *Ø¥Ù„ØºØ§Ø¡* Ù„Ù„Ø®Ø±ÙˆØ¬${signature}
    `);
    
    userState.set(userId, { 
        step: 'professors_action', 
        timestamp: Date.now() 
    });
}

async function handleProfessorsAction(message, replyTo, senderName, signature, userId, currentGroupId, content) {
    if (content === '1') { // Display professors
        let professorsList = "ğŸ“‹ *Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø£Ø³Ø§ØªØ°Ø©*\n\n";
        if (professors.size === 0) {
            professorsList += "Ù„Ø§ ÙŠÙˆØ¬Ø¯ Ø£Ø³Ø§ØªØ°Ø© Ù…Ø¶Ø§ÙÙŠÙ† Ø¨Ø¹Ø¯.";
        } else {
            let index = 1;
            for (const [id, name] of professors) {
                professorsList += `${index}. ${name} (ID: ${id})\n`;
                index++;
            }
        }
        
        await client.sendMessage(replyTo, `${professorsList}${signature}`);
        userState.delete(userId);
    } else if (content === '2') { // Add professor
        await client.sendMessage(replyTo, `
ğŸ“ *Ø¥Ø¶Ø§ÙØ© Ø£Ø³ØªØ§Ø° Ø¬Ø¯ÙŠØ¯*

ÙŠØ±Ø¬Ù‰ Ø¥Ø±Ø³Ø§Ù„ Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„Ø£Ø³ØªØ§Ø° Ø¨Ø§Ù„ØªÙ†Ø³ÙŠÙ‚ Ø§Ù„ØªØ§Ù„ÙŠ:
Ø§Ø³Ù… Ø§Ù„Ø£Ø³ØªØ§Ø°: [Ø§Ø³Ù… Ø§Ù„Ø£Ø³ØªØ§Ø°]
Ù…Ø¹Ø±Ù Ø§Ù„Ø£Ø³ØªØ§Ø°: [Ù…Ø¹Ø±Ù Ø§Ù„Ø£Ø³ØªØ§Ø°]

ğŸ’¡ Ù…Ø«Ø§Ù„:
Ø§Ø³Ù… Ø§Ù„Ø£Ø³ØªØ§Ø°: Ø¯. Ø£Ø­Ù…Ø¯ Ù…Ø­Ù…Ø¯
Ù…Ø¹Ø±Ù Ø§Ù„Ø£Ø³ØªØ§Ø°: prof1

ğŸ’¡ Ø£Ø±Ø³Ù„ *Ø¥Ù„ØºØ§Ø¡* Ù„Ù„Ø®Ø±ÙˆØ¬${signature}
        `);
        
        userState.set(userId, { 
            step: 'add_professor', 
            timestamp: Date.now() 
        });
    } else if (content === '3') { // Edit professor
        if (professors.size === 0) {
            await client.sendMessage(replyTo, `âš ï¸ Ù„Ø§ ÙŠÙˆØ¬Ø¯ Ø£Ø³Ø§ØªØ°Ø© Ù„Ù„ØªØ¹Ø¯ÙŠÙ„${signature}`);
            userState.delete(userId);
            return;
        }
        
        let professorsList = "ğŸ“ *Ø§Ø®ØªØ± Ø£Ø³ØªØ§Ø°Ø§Ù‹ Ù„Ù„ØªØ¹Ø¯ÙŠÙ„*\n\n";
        let index = 1;
        for (const [id, name] of professors) {
            professorsList += `${index}. ${name} (ID: ${id})\n`;
            index++;
        }
        
        await client.sendMessage(replyTo, `
${professorsList}

ğŸ’¡ Ø£Ø±Ø³Ù„ Ø±Ù‚Ù… Ø§Ù„Ø£Ø³ØªØ§Ø° Ø£Ùˆ *Ø¥Ù„ØºØ§Ø¡* Ù„Ù„Ø®Ø±ÙˆØ¬${signature}
        `);
        
        userState.set(userId, { 
            step: 'edit_professor_select', 
            timestamp: Date.now() 
        });
    } else if (content === '4') { // Delete professor
        if (professors.size === 0) {
            await client.sendMessage(replyTo, `âš ï¸ Ù„Ø§ ÙŠÙˆØ¬Ø¯ Ø£Ø³Ø§ØªØ°Ø© Ù„Ù„Ø­Ø°Ù${signature}`);
            userState.delete(userId);
            return;
        }
        
        let professorsList = "ğŸ—‘ï¸ *Ø§Ø®ØªØ± Ø£Ø³ØªØ§Ø°Ø§Ù‹ Ù„Ù„Ø­Ø°Ù*\n\n";
        let index = 1;
        for (const [id, name] of professors) {
            professorsList += `${index}. ${name} (ID: ${id})\n`;
            index++;
        }
        
        await client.sendMessage(replyTo, `
${professorsList}

âš ï¸ ØªØ­Ø°ÙŠØ±: Ø³ÙŠØªÙ… Ø­Ø°Ù Ø§Ù„Ø£Ø³ØªØ§Ø° ÙˆØ¬Ù…ÙŠØ¹ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ø±ØªØ¨Ø·Ø© Ø¨Ù‡!

ğŸ’¡ Ø£Ø±Ø³Ù„ Ø±Ù‚Ù… Ø§Ù„Ø£Ø³ØªØ§Ø° Ø£Ùˆ *Ø¥Ù„ØºØ§Ø¡* Ù„Ù„Ø®Ø±ÙˆØ¬${signature}
        `);
        
        userState.set(userId, { 
            step: 'delete_professor_select', 
            timestamp: Date.now() 
        });
    } else {
        await client.sendMessage(replyTo, `âš ï¸ Ø®ÙŠØ§Ø± ØºÙŠØ± ØµØ§Ù„Ø­. ÙŠØ±Ø¬Ù‰ Ø¥Ø±Ø³Ø§Ù„ Ø±Ù‚Ù… Ù…Ù† 1 Ø¥Ù„Ù‰ 4${signature}`);
    }
}

async function handleAddProfessor(message, replyTo, senderName, signature, userId, currentGroupId, content) {
    const nameMatch = content.match(/Ø§Ø³Ù… Ø§Ù„Ø£Ø³ØªØ§Ø°:\s*(.+)/i);
    const idMatch = content.match(/Ù…Ø¹Ø±Ù Ø§Ù„Ø£Ø³ØªØ§Ø°:\s*(.+)/i);
    
    if (!nameMatch || !idMatch) {
        await client.sendMessage(replyTo, `âš ï¸ ØªÙ†Ø³ÙŠÙ‚ ØºÙŠØ± ØµØ§Ù„Ø­. ÙŠØ±Ø¬Ù‰ Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø¨Ø§Ù„ØªÙ†Ø³ÙŠÙ‚ Ø§Ù„Ù…Ø·Ù„ÙˆØ¨${signature}`);
        return;
    }
    
    const name = nameMatch[1].trim();
    const id = idMatch[1].trim();
    
    if (professors.has(id)) {
        await client.sendMessage(replyTo, `âš ï¸ Ù…Ø¹Ø±Ù Ø§Ù„Ø£Ø³ØªØ§Ø° "${id}" Ù…ÙˆØ¬ÙˆØ¯ Ø¨Ø§Ù„ÙØ¹Ù„${signature}`);
        userState.delete(userId);
        return;
    }
    
    professors.set(id, name);
    await saveProfessors();
    
    await client.sendMessage(replyTo, `âœ… ØªÙ…Øª Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ø£Ø³ØªØ§Ø° "${name}" Ø¨Ù†Ø¬Ø§Ø­${signature}`);
    userState.delete(userId);
}

async function handleEditProfessorSelect(message, replyTo, senderName, signature, userId, currentGroupId, content) {
    const index = parseInt(content) - 1;
    if (isNaN(index) || index < 0 || index >= professors.size) {
        await client.sendMessage(replyTo, `âš ï¸ Ø±Ù‚Ù… ØºÙŠØ± ØµØ§Ù„Ø­. ÙŠØ±Ø¬Ù‰ Ø¥Ø±Ø³Ø§Ù„ Ø±Ù‚Ù… Ø£Ø³ØªØ§Ø° ØµØ­ÙŠØ­${signature}`);
        return;
    }
    
    const professorId = Array.from(professors.keys())[index];
    const professorName = professors.get(professorId);
    
    await client.sendMessage(replyTo, `
ğŸ“ *ØªØ¹Ø¯ÙŠÙ„ Ø§Ù„Ø£Ø³ØªØ§Ø°*

Ø§Ù„Ø£Ø³ØªØ§Ø° Ø§Ù„Ø­Ø§Ù„ÙŠ: ${professorName} (ID: ${professorId})

ÙŠØ±Ø¬Ù‰ Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„Ø¬Ø¯ÙŠØ¯Ø© Ø¨Ø§Ù„ØªÙ†Ø³ÙŠÙ‚ Ø§Ù„ØªØ§Ù„ÙŠ:
Ø§Ø³Ù… Ø§Ù„Ø£Ø³ØªØ§Ø°: [Ø§Ù„Ø§Ø³Ù… Ø§Ù„Ø¬Ø¯ÙŠØ¯]
Ù…Ø¹Ø±Ù Ø§Ù„Ø£Ø³ØªØ§Ø°: [Ø§Ù„Ù…Ø¹Ø±Ù Ø§Ù„Ø¬Ø¯ÙŠØ¯]

ğŸ’¡ Ø£Ø±Ø³Ù„ *Ø¥Ù„ØºØ§Ø¡* Ù„Ù„Ø®Ø±ÙˆØ¬${signature}
    `);
    
    userState.set(userId, { 
        step: 'edit_professor', 
        timestamp: Date.now(),
        professorId: professorId
    });
}

async function handleEditProfessor(message, replyTo, senderName, signature, userId, currentGroupId, content) {
    const nameMatch = content.match(/Ø§Ø³Ù… Ø§Ù„Ø£Ø³ØªØ§Ø°:\s*(.+)/i);
    const idMatch = content.match(/Ù…Ø¹Ø±Ù Ø§Ù„Ø£Ø³ØªØ§Ø°:\s*(.+)/i);
    
    if (!nameMatch || !idMatch) {
        await client.sendMessage(replyTo, `âš ï¸ ØªÙ†Ø³ÙŠÙ‚ ØºÙŠØ± ØµØ§Ù„Ø­. ÙŠØ±Ø¬Ù‰ Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø¨Ø§Ù„ØªÙ†Ø³ÙŠÙ‚ Ø§Ù„Ù…Ø·Ù„ÙˆØ¨${signature}`);
        return;
    }
    
    const name = nameMatch[1].trim();
    const id = idMatch[1].trim();
    const oldId = userState.get(userId).professorId;
    
    // Check if new ID already exists and it's not the same as the old one
    if (id !== oldId && professors.has(id)) {
        await client.sendMessage(replyTo, `âš ï¸ Ù…Ø¹Ø±Ù Ø§Ù„Ø£Ø³ØªØ§Ø° "${id}" Ù…ÙˆØ¬ÙˆØ¯ Ø¨Ø§Ù„ÙØ¹Ù„${signature}`);
        userState.delete(userId);
        return;
    }
    
    // Delete old entry if ID is changing
    if (id !== oldId) {
        professors.delete(oldId);
    }
    
    professors.set(id, name);
    await saveProfessors();
    
    await client.sendMessage(replyTo, `âœ… ØªÙ… ØªØ¹Ø¯ÙŠÙ„ Ø§Ù„Ø£Ø³ØªØ§Ø° Ø¨Ù†Ø¬Ø§Ø­${signature}`);
    userState.delete(userId);
}

async function handleDeleteProfessorSelect(message, replyTo, senderName, signature, userId, currentGroupId, content) {
    const index = parseInt(content) - 1;
    if (isNaN(index) || index < 0 || index >= professors.size) {
        await client.sendMessage(replyTo, `âš ï¸ Ø±Ù‚Ù… ØºÙŠØ± ØµØ§Ù„Ø­. ÙŠØ±Ø¬Ù‰ Ø¥Ø±Ø³Ø§Ù„ Ø±Ù‚Ù… Ø£Ø³ØªØ§Ø° ØµØ­ÙŠØ­${signature}`);
        return;
    }
    
    const professorId = Array.from(professors.keys())[index];
    const professorName = professors.get(professorId);
    
    // Confirm deletion
    await client.sendMessage(replyTo, `
âš ï¸ *ØªØ£ÙƒÙŠØ¯ Ø§Ù„Ø­Ø°Ù*

Ù‡Ù„ Ø£Ù†Øª Ù…ØªØ£ÙƒØ¯ Ù…Ù† Ø­Ø°Ù Ø§Ù„Ø£Ø³ØªØ§Ø° "${professorName}"ØŸ

Ù‡Ø°Ø§ Ø§Ù„Ø¥Ø¬Ø±Ø§Ø¡ Ù„Ø§ ÙŠÙ…ÙƒÙ† Ø§Ù„ØªØ±Ø§Ø¬Ø¹ Ø¹Ù†Ù‡.

ğŸ’¡ Ø£Ø±Ø³Ù„ *ØªØ£ÙƒÙŠØ¯* Ù„Ù„Ø­Ø°Ù Ø£Ùˆ *Ø¥Ù„ØºØ§Ø¡* Ù„Ù„Ø¥Ù„ØºØ§Ø¡${signature}
    `);
    
    userState.set(userId, { 
        step: 'confirm_delete_professor', 
        timestamp: Date.now(),
        professorId: professorId,
        professorName: professorName
    });
}

// Helper functions for subjects management
async function handleSubjectsManagement(message, replyTo, senderName, signature, userId, currentGroupId) {
    await message.react('ğŸ“‹');
    
    let subjectsList = "ğŸ“‹ *Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ù…ÙˆØ§Ø¯*\n\n";
    if (subjects.size === 0) {
        subjectsList += "Ù„Ø§ ØªÙˆØ¬Ø¯ Ù…ÙˆØ§Ø¯ Ù…Ø¶Ø§ÙØ© Ø¨Ø¹Ø¯.";
    } else {
        let index = 1;
        for (const [id, name] of subjects) {
            subjectsList += `${index}. ${name} (ID: ${id})\n`;
            index++;
        }
    }
    
    await client.sendMessage(replyTo, `
${subjectsList}

Ù…Ø§Ø°Ø§ ØªØ±ÙŠØ¯ Ø£Ù† ØªÙØ¹Ù„ØŸ

1. Ø¹Ø±Ø¶ Ø§Ù„Ù…ÙˆØ§Ø¯
2. Ø¥Ø¶Ø§ÙØ© Ù…Ø§Ø¯Ø© Ø¬Ø¯ÙŠØ¯Ø©
3. ØªØ¹Ø¯ÙŠÙ„ Ù…Ø§Ø¯Ø©
4. Ø­Ø°Ù Ù…Ø§Ø¯Ø©

ğŸ’¡ Ø£Ø±Ø³Ù„ Ø±Ù‚Ù… Ø§Ù„Ø®ÙŠØ§Ø± Ø£Ùˆ *Ø¥Ù„ØºØ§Ø¡* Ù„Ù„Ø®Ø±ÙˆØ¬${signature}
    `);
    
    userState.set(userId, { 
        step: 'subjects_action', 
        timestamp: Date.now() 
    });
}

async function handleSubjectsAction(message, replyTo, senderName, signature, userId, currentGroupId, content) {
    if (content === '1') { // Display subjects
        let subjectsList = "ğŸ“‹ *Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ù…ÙˆØ§Ø¯*\n\n";
        if (subjects.size === 0) {
            subjectsList += "Ù„Ø§ ØªÙˆØ¬Ø¯ Ù…ÙˆØ§Ø¯ Ù…Ø¶Ø§ÙØ© Ø¨Ø¹Ø¯.";
        } else {
            let index = 1;
            for (const [id, name] of subjects) {
                subjectsList += `${index}. ${name} (ID: ${id})\n`;
                index++;
            }
        }
        
        await client.sendMessage(replyTo, `${subjectsList}${signature}`);
        userState.delete(userId);
    } else if (content === '2') { // Add subject
        await client.sendMessage(replyTo, `
ğŸ“ *Ø¥Ø¶Ø§ÙØ© Ù…Ø§Ø¯Ø© Ø¬Ø¯ÙŠØ¯Ø©*

ÙŠØ±Ø¬Ù‰ Ø¥Ø±Ø³Ø§Ù„ Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„Ù…Ø§Ø¯Ø© Ø¨Ø§Ù„ØªÙ†Ø³ÙŠÙ‚ Ø§Ù„ØªØ§Ù„ÙŠ:
Ø§Ø³Ù… Ø§Ù„Ù…Ø§Ø¯Ø©: [Ø§Ø³Ù… Ø§Ù„Ù…Ø§Ø¯Ø©]
Ù…Ø¹Ø±Ù Ø§Ù„Ù…Ø§Ø¯Ø©: [Ù…Ø¹Ø±Ù Ø§Ù„Ù…Ø§Ø¯Ø©]

ğŸ’¡ Ù…Ø«Ø§Ù„:
Ø§Ø³Ù… Ø§Ù„Ù…Ø§Ø¯Ø©: Ø§Ù„Ø±ÙŠØ§Ø¶ÙŠØ§Øª
Ù…Ø¹Ø±Ù Ø§Ù„Ù…Ø§Ø¯Ø©: math

ğŸ’¡ Ø£Ø±Ø³Ù„ *Ø¥Ù„ØºØ§Ø¡* Ù„Ù„Ø®Ø±ÙˆØ¬${signature}
        `);
        
        userState.set(userId, { 
            step: 'add_subject', 
            timestamp: Date.now() 
        });
    } else if (content === '3') { // Edit subject
        if (subjects.size === 0) {
            await client.sendMessage(replyTo, `âš ï¸ Ù„Ø§ ØªÙˆØ¬Ø¯ Ù…ÙˆØ§Ø¯ Ù„Ù„ØªØ¹Ø¯ÙŠÙ„${signature}`);
            userState.delete(userId);
            return;
        }
        
        let subjectsList = "ğŸ“ *Ø§Ø®ØªØ± Ù…Ø§Ø¯Ø© Ù„Ù„ØªØ¹Ø¯ÙŠÙ„*\n\n";
        let index = 1;
        for (const [id, name] of subjects) {
            subjectsList += `${index}. ${name} (ID: ${id})\n`;
            index++;
        }
        
        await client.sendMessage(replyTo, `
${subjectsList}

ğŸ’¡ Ø£Ø±Ø³Ù„ Ø±Ù‚Ù… Ø§Ù„Ù…Ø§Ø¯Ø© Ø£Ùˆ *Ø¥Ù„ØºØ§Ø¡* Ù„Ù„Ø®Ø±ÙˆØ¬${signature}
        `);
        
        userState.set(userId, { 
            step: 'edit_subject_select', 
            timestamp: Date.now() 
        });
    } else if (content === '4') { // Delete subject
        if (subjects.size === 0) {
            await client.sendMessage(replyTo, `âš ï¸ Ù„Ø§ ØªÙˆØ¬Ø¯ Ù…ÙˆØ§Ø¯ Ù„Ù„Ø­Ø°Ù${signature}`);
            userState.delete(userId);
            return;
        }
        
        let subjectsList = "ğŸ—‘ï¸ *Ø§Ø®ØªØ± Ù…Ø§Ø¯Ø© Ù„Ù„Ø­Ø°Ù*\n\n";
        let index = 1;
        for (const [id, name] of subjects) {
            subjectsList += `${index}. ${name} (ID: ${id})\n`;
            index++;
        }
        
        await client.sendMessage(replyTo, `
${subjectsList}

âš ï¸ ØªØ­Ø°ÙŠØ±: Ø³ÙŠØªÙ… Ø­Ø°Ù Ø§Ù„Ù…Ø§Ø¯Ø© ÙˆØ¬Ù…ÙŠØ¹ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ø±ØªØ¨Ø·Ø© Ø¨Ù‡Ø§!

ğŸ’¡ Ø£Ø±Ø³Ù„ Ø±Ù‚Ù… Ø§Ù„Ù…Ø§Ø¯Ø© Ø£Ùˆ *Ø¥Ù„ØºØ§Ø¡* Ù„Ù„Ø®Ø±ÙˆØ¬${signature}
        `);
        
        userState.set(userId, { 
            step: 'delete_subject_select', 
            timestamp: Date.now() 
        });
    } else {
        await client.sendMessage(replyTo, `âš ï¸ Ø®ÙŠØ§Ø± ØºÙŠØ± ØµØ§Ù„Ø­. ÙŠØ±Ø¬Ù‰ Ø¥Ø±Ø³Ø§Ù„ Ø±Ù‚Ù… Ù…Ù† 1 Ø¥Ù„Ù‰ 4${signature}`);
    }
}

async function handleAddSubject(message, replyTo, senderName, signature, userId, currentGroupId, content) {
    const nameMatch = content.match(/Ø§Ø³Ù… Ø§Ù„Ù…Ø§Ø¯Ø©:\s*(.+)/i);
    const idMatch = content.match(/Ù…Ø¹Ø±Ù Ø§Ù„Ù…Ø§Ø¯Ø©:\s*(.+)/i);
    
    if (!nameMatch || !idMatch) {
        await client.sendMessage(replyTo, `âš ï¸ ØªÙ†Ø³ÙŠÙ‚ ØºÙŠØ± ØµØ§Ù„Ø­. ÙŠØ±Ø¬Ù‰ Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø¨Ø§Ù„ØªÙ†Ø³ÙŠÙ‚ Ø§Ù„Ù…Ø·Ù„ÙˆØ¨${signature}`);
        return;
    }
    
    const name = nameMatch[1].trim();
    const id = idMatch[1].trim();
    
    if (subjects.has(id)) {
        await client.sendMessage(replyTo, `âš ï¸ Ù…Ø¹Ø±Ù Ø§Ù„Ù…Ø§Ø¯Ø© "${id}" Ù…ÙˆØ¬ÙˆØ¯ Ø¨Ø§Ù„ÙØ¹Ù„${signature}`);
        userState.delete(userId);
        return;
    }
    
    subjects.set(id, name);
    await saveSubjects();
    
    await client.sendMessage(replyTo, `âœ… ØªÙ…Øª Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ù…Ø§Ø¯Ø© "${name}" Ø¨Ù†Ø¬Ø§Ø­${signature}`);
    userState.delete(userId);
}

async function handleEditSubjectSelect(message, replyTo, senderName, signature, userId, currentGroupId, content) {
    const index = parseInt(content) - 1;
    if (isNaN(index) || index < 0 || index >= subjects.size) {
        await client.sendMessage(replyTo, `âš ï¸ Ø±Ù‚Ù… ØºÙŠØ± ØµØ§Ù„Ø­. ÙŠØ±Ø¬Ù‰ Ø¥Ø±Ø³Ø§Ù„ Ø±Ù‚Ù… Ù…Ø§Ø¯Ø© ØµØ­ÙŠØ­${signature}`);
        return;
    }
    
    const subjectId = Array.from(subjects.keys())[index];
    const subjectName = subjects.get(subjectId);
    
    await client.sendMessage(replyTo, `
ğŸ“ *ØªØ¹Ø¯ÙŠÙ„ Ø§Ù„Ù…Ø§Ø¯Ø©*

Ø§Ù„Ù…Ø§Ø¯Ø© Ø§Ù„Ø­Ø§Ù„ÙŠØ©: ${subjectName} (ID: ${subjectId})

ÙŠØ±Ø¬Ù‰ Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„Ø¬Ø¯ÙŠØ¯Ø© Ø¨Ø§Ù„ØªÙ†Ø³ÙŠÙ‚ Ø§Ù„ØªØ§Ù„ÙŠ:
Ø§Ø³Ù… Ø§Ù„Ù…Ø§Ø¯Ø©: [Ø§Ù„Ø§Ø³Ù… Ø§Ù„Ø¬Ø¯ÙŠØ¯]
Ù…Ø¹Ø±Ù Ø§Ù„Ù…Ø§Ø¯Ø©: [Ø§Ù„Ù…Ø¹Ø±Ù Ø§Ù„Ø¬Ø¯ÙŠØ¯]

ğŸ’¡ Ø£Ø±Ø³Ù„ *Ø¥Ù„ØºØ§Ø¡* Ù„Ù„Ø®Ø±ÙˆØ¬${signature}
    `);
    
    userState.set(userId, { 
        step: 'edit_subject', 
        timestamp: Date.now(),
        subjectId: subjectId
    });
}

async function handleEditSubject(message, replyTo, senderName, signature, userId, currentGroupId, content) {
    const nameMatch = content.match(/Ø§Ø³Ù… Ø§Ù„Ù…Ø§Ø¯Ø©:\s*(.+)/i);
    const idMatch = content.match(/Ù…Ø¹Ø±Ù Ø§Ù„Ù…Ø§Ø¯Ø©:\s*(.+)/i);
    
    if (!nameMatch || !idMatch) {
        await client.sendMessage(replyTo, `âš ï¸ ØªÙ†Ø³ÙŠÙ‚ ØºÙŠØ± ØµØ§Ù„Ø­. ÙŠØ±Ø¬Ù‰ Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø¨Ø§Ù„ØªÙ†Ø³ÙŠÙ‚ Ø§Ù„Ù…Ø·Ù„ÙˆØ¨${signature}`);
        return;
    }
    
    const name = nameMatch[1].trim();
    const id = idMatch[1].trim();
    const oldId = userState.get(userId).subjectId;
    
    // Check if new ID already exists and it's not the same as the old one
    if (id !== oldId && subjects.has(id)) {
        await client.sendMessage(replyTo, `âš ï¸ Ù…Ø¹Ø±Ù Ø§Ù„Ù…Ø§Ø¯Ø© "${id}" Ù…ÙˆØ¬ÙˆØ¯ Ø¨Ø§Ù„ÙØ¹Ù„${signature}`);
        userState.delete(userId);
        return;
    }
    
    // Delete old entry if ID is changing
    if (id !== oldId) {
        subjects.delete(oldId);
    }
    
    subjects.set(id, name);
    await saveSubjects();
    
    await client.sendMessage(replyTo, `âœ… ØªÙ… ØªØ¹Ø¯ÙŠÙ„ Ø§Ù„Ù…Ø§Ø¯Ø© Ø¨Ù†Ø¬Ø§Ø­${signature}`);
    userState.delete(userId);
}

async function handleDeleteSubjectSelect(message, replyTo, senderName, signature, userId, currentGroupId, content) {
    const index = parseInt(content) - 1;
    if (isNaN(index) || index < 0 || index >= subjects.size) {
        await client.sendMessage(replyTo, `âš ï¸ Ø±Ù‚Ù… ØºÙŠØ± ØµØ§Ù„Ø­. ÙŠØ±Ø¬Ù‰ Ø¥Ø±Ø³Ø§Ù„ Ø±Ù‚Ù… Ù…Ø§Ø¯Ø© ØµØ­ÙŠØ­${signature}`);
        return;
    }
    
    const subjectId = Array.from(subjects.keys())[index];
    const subjectName = subjects.get(subjectId);
    
    // Confirm deletion
    await client.sendMessage(replyTo, `
âš ï¸ *ØªØ£ÙƒÙŠØ¯ Ø§Ù„Ø­Ø°Ù*

Ù‡Ù„ Ø£Ù†Øª Ù…ØªØ£ÙƒØ¯ Ù…Ù† Ø­Ø°Ù Ø§Ù„Ù…Ø§Ø¯Ø© "${subjectName}"ØŸ

Ù‡Ø°Ø§ Ø§Ù„Ø¥Ø¬Ø±Ø§Ø¡ Ù„Ø§ ÙŠÙ…ÙƒÙ† Ø§Ù„ØªØ±Ø§Ø¬Ø¹ Ø¹Ù†Ù‡.

ğŸ’¡ Ø£Ø±Ø³Ù„ *ØªØ£ÙƒÙŠØ¯* Ù„Ù„Ø­Ø°Ù Ø£Ùˆ *Ø¥Ù„ØºØ§Ø¡* Ù„Ù„Ø¥Ù„ØºØ§Ø¡${signature}
    `);
    
    userState.set(userId, { 
        step: 'confirm_delete_subject', 
        timestamp: Date.now(),
        subjectId: subjectId,
        subjectName: subjectName
    });
}

// Handle confirmation of deletion for all types
async function handleConfirmDelete(message, replyTo, senderName, signature, userId, currentGroupId, content, step) {
    if (content === 'ØªØ£ÙƒÙŠØ¯' || content === 'confirm') {
        const state = userState.get(userId);
        
        switch (step) {
            case 'confirm_delete_section':
                sections.delete(state.sectionId);
                await saveSections();
                await client.sendMessage(replyTo, `âœ… ØªÙ… Ø­Ø°Ù Ø§Ù„Ø´Ø¹Ø¨Ø© "${state.sectionName}" Ø¨Ù†Ø¬Ø§Ø­${signature}`);
                break;
                
            case 'confirm_delete_class':
                classes.delete(state.classId);
                await saveClasses();
                await client.sendMessage(replyTo, `âœ… ØªÙ… Ø­Ø°Ù Ø§Ù„ÙØµÙ„ "${state.className}" Ø¨Ù†Ø¬Ø§Ø­${signature}`);
                break;
                
            case 'confirm_delete_group':
                groupsData.delete(state.groupId);
                await saveGroups();
                await client.sendMessage(replyTo, `âœ… ØªÙ… Ø­Ø°Ù Ø§Ù„ÙÙˆØ¬ "${state.groupName}" Ø¨Ù†Ø¬Ø§Ø­${signature}`);
                break;
                
            case 'confirm_delete_professor':
                professors.delete(state.professorId);
                await saveProfessors();
                await client.sendMessage(replyTo, `âœ… ØªÙ… Ø­Ø°Ù Ø§Ù„Ø£Ø³ØªØ§Ø° "${state.professorName}" Ø¨Ù†Ø¬Ø§Ø­${signature}`);
                break;
                
            case 'confirm_delete_subject':
                subjects.delete(state.subjectId);
                await saveSubjects();
                await client.sendMessage(replyTo, `âœ… ØªÙ… Ø­Ø°Ù Ø§Ù„Ù…Ø§Ø¯Ø© "${state.subjectName}" Ø¨Ù†Ø¬Ø§Ø­${signature}`);
                break;
        }
        
        userState.delete(userId);
    } else if (content === 'Ø¥Ù„ØºØ§Ø¡' || content === 'cancel') {
        await client.sendMessage(replyTo, `âœ… ØªÙ… Ø¥Ù„ØºØ§Ø¡ Ø¹Ù…Ù„ÙŠØ© Ø§Ù„Ø­Ø°Ù${signature}`);
        userState.delete(userId);
    } else {
        await client.sendMessage(replyTo, `âš ï¸ ÙŠØ±Ø¬Ù‰ Ø¥Ø±Ø³Ø§Ù„ *ØªØ£ÙƒÙŠØ¯* Ø£Ùˆ *Ø¥Ù„ØºØ§Ø¡*${signature}`);
    }
}

// Initialize the client
client.initialize();